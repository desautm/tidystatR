[["index.html", "Statistiques et Probabilités avec R, RStudio et le Tidyverse Introduction", " Statistiques et Probabilités avec R, RStudio et le Tidyverse Marc-André Désautels 2021-04-15 Introduction Nous sommes constamment bombardés dinformation. Que ce soit sur Internet, à la télévision ou à la radio, les résultats de sondage abondent. Comment faire pour déterminer quelle information est fiable? Ce cours vise à faire de vous des citoyens critiques, capables danalyser des données et den tirer des conclusions. "],["rrstudio.html", "Chapitre 1 Les logiciels R et RStudio 1.1 Quest-ce que R? 1.2 Quest-ce que RStudio? 1.3 Les bases de RStudio", " Chapitre 1 Les logiciels R et RStudio Ce chapitre est inspiré de (Barnier 2018) et de (Ismay 2018). 1.1 Quest-ce que R? R est un langage orienté vers le traitement et lanalyse quantitative de données. Il est développé depuis les années 90 par un groupe de volontaires de différents pays et par une large communauté dutilisateurs. Cest un logiciel libre, publié sous licence GNU GPL. R a été créé par Ross Ihaka et Robert Gentleman en Nouvelle-Zélande à lUniversité dAuclkand. Voici les avantages les plus importants de R: R est un logiciel gratuit. R est un logiciel très puissant, dont les fonctionnalités de base peuvent être étendues à laide dextensions développées par la communauté. Il en existe plusieurs milliers. R est un logiciel dont le développement est très actif et dont la communauté dutilisateurs et lusage ne cessent de sagrandir. Il est possible de trouver des réponses à ses questions assez facilement grâce à laide incluse, à la communauté, à Google, etc. Bien que laide soit en anglais, il existe des communautés francophones qui utilisent le logiciel. R nest pas un logiciel au sens classique du terme, mais plutôt un langage de programmation. Il fonctionne à laide de scripts (des petits programmes) édités et exécutés au fur et à mesure de lanalyse. Ce point, qui peut apparaître comme un gros handicap, savère après un temps dapprentissage être un mode dutilisation dune grande souplesse. Laspect langage de programmation et la difficulté qui en découle peuvent sembler des inconvénients importants. Le fait de structurer ses analyses sous forme de scripts (suite dinstructions effectuant les différentes opérations dune analyse) présente cependant de nombreux avantages : le script garde par ordre chronologique lensemble des étapes dune analyse, de limportation des données à leur analyse en passant par les manipulations et les recodages on peut à tout moment revenir en arrière et modifier ce qui a été fait il est très rapide de réexécuter une suite dopérations complexes on peut très facilement mettre à jour les résultats en cas de modification des données sources le script garantit, sous certaines conditions, la reproductibilité des résultats obtenus Pour télécharger le logiciel R, vous allez à ladresse suivante: https://www.r-project.org/ 1.2 Quest-ce que RStudio? RStudio nest pas à proprement parler une interface graphique pour R, il sagit plutôt dun environnement de développement intégré (integrated development environment en anglais), qui propose des outils et facilite lécriture de scripts et lusage de R au quotidien. Cest une interface bien supérieure à celles fournies par défaut lorsquon installe R sous Windows ou sous Mac. Il existe plusieurs versions de RStudio: RStudio Desktop RStudio Server RStudio Cloud Pour télécharger la version Desktop de RStudio (que vous pouvez utilisez sur votre ordinateur), vous allez à ladresse suivante: https://www.rstudio.com/products/rstudio/download/#download 1.3 Les bases de RStudio 1.3.1 La console Au premier lancement de RStudio, lécran est séparé en trois grandes zones: Figure 1.1: Linterface de RStudio La zone de gauche se nomme Console. À son démarrage, RStudio a lancé une nouvelle session de R et cest dans cette fenêtre que nous allons pouvoir interagir avec lui. Vous devriez voir un texte ressemblant à celui-ci: R version 3.4.4 (2018-03-15) -- &quot;Someone to Lean On&quot; Copyright (C) 2018 The R Foundation for Statistical Computing Platform: x86_64-w64-mingw32/x64 (64-bit) R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under certain conditions. Type &#39;license()&#39; or &#39;licence()&#39; for distribution details. R is a collaborative project with many contributors. Type &#39;contributors()&#39; for more information and &#39;citation()&#39; on how to cite R or R packages in publications. Type &#39;demo()&#39; for some demos, &#39;help()&#39; for on-line help, or &#39;help.start()&#39; for an HTML browser interface to help. Type &#39;q()&#39; to quit R. La console ressemble à ceci: Figure 1.2: La console R La ligne qui débute avec le symbole &gt; est appelée linvite de commande (ou prompt en anglais). Elle signifie que R est disponible et en attente de votre prochaine commande. Cest à cet endroit que nous pouvons entrer des commandes et les éxécuter en appuyabt sur Entrée. 1.3.2 Environment/History/Connections Figure 1.3: La zone Environment/History/Connections 1.3.3 Files/Plots/Packages/Help/Viewer Figure 1.4: La zone Files/Plots/Packages/Help/Viewer Vous pouvez chercher de laide dans longlet Help de linterface de RStudio (voir la figure 1.4) et utiliser le moteur de recherche intégré. Chaque page daide est très complète mais pas toujours très accessible. Elle est structurée selon différentes sections, notamment : Description : donne un résumé en une phrase de ce que fait la fonction Usage : indique la ou les manières de lutiliser Arguments : détaille les arguments possibles et leur signification Value : indique la forme du résultat renvoyé par la fonction Details : apporte des précisions sur le fonctionnement de la fonction See Also : renvoit vers dautres fonctions semblables ou liées, ce qui peut être très utile pour découvrir ou retrouver une fonction dont on a oublié le nom Examples : donne une série dexemples dutilisation Les exemples dune page daide peuvent être exécutés directement dans la console avec la fonction example : example(&quot;mean&quot;) #&gt; #&gt; mean&gt; x &lt;- c(0:10, 50) #&gt; #&gt; mean&gt; xm &lt;- mean(x) #&gt; #&gt; mean&gt; c(xm, mean(x, trim = 0.10)) #&gt; [1] 8.75 5.50 Longlet Help de RStudio permet dafficher mais aussi de naviguer dans les pages daide de R et dans dautres ressources : 1.3.4 Aller chercher de laide Il est possible dobtenir à tout moment de laide (en anglais) sur une fonction en tapant help() avec comme argument le nom de la fonction dans la console : help(&quot;mean&quot;) Il est aussi possible dutiliser lopérateur ?. Par exemple: ?mean "],["tidyverse.html", "Chapitre 2 Le tidyverse 2.1 Extensions 2.2 Installation 2.3 Les tidy data 2.4 Les tibbles", " Chapitre 2 Le tidyverse Dans ce document, nous utiliserons lextension tidyverse par (Wickham 2019). Ce chapitre permettra dintroduire lextension tidyverse mais surtout les principes qui la sous-tendent. Ce chapitre est inspiré de (Barnier 2018) et (Wickham and Grolemund 2017). library(tidyverse) library(questionr) 2.1 Extensions Le terme tidyverse est une contraction de tidy (quon pourrait traduire par bien rangé) et de universe. En allant visiter le site internet de ces extensions https://www.tidyverse.org/, voici ce que nous pouvons trouver sur la première page du site: The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures. que nous pourrions traduire par: Le tidyverse est une collection dogmatique dextensions pour le langage R conçues pour la science des données. Toutes les extensions partagent une philosphie sous-jacente de design, de grammaire et de structures de données. Ces extensions abordent un très grand nombre dopérations courantes dans R. Lavantage dutiliser le tidyverse cest quil permet de simplifier plusieurs opérations fréquentes et il introduit le concept de tidy data. De plus, la grammaire du tidyverse étant cohérente entre toutes ses extensions, en apprenant comment utiliser lune de ces extensions, vous serez en monde connu lorsque viendra le temps dapprendre de nouvelles extensions. Nous utiliserons le tidyverse pour: Le concept de tidy data Limportation et/ou lexportation de données La manipulation de variables La visualisation Le tidyverse permet aussi de: Travailler avec des chaînes de caractères (du texte par exemple) Programmer Remettre en forme des données Extraire des données du Web Etc. Pour en savoir plus, nous invitons le lecteur à se rendre au site du tidyverse https://www.tidyverse.org/. Le tidyverse est en grande partie issu des travaux de Hadley Wickham. 2.2 Installation Pour installer les extensions du tidyverse, nous effectuons la commande suivante: install.packages(&quot;tidyverse&quot;) Une fois lextension installée, il nest pas nécessaire de la réinstaller à chaque fois que vous utilisez R. Par contre, vous devez charger lextension à chaque fois que vous utilisez R. Pour charger lextension et lutiliser dans R, nous effectuons la commande suivante: library(tidyverse) Cette commande va en fait charger plusieurs extensions qui constituent le coeur du tidyverse, à savoir : ggplot2 (visualisation) dplyr (manipulation des données) tidyr (remise en forme des données) purrr (programmation) readr (importation de données) tibble (tableaux de données) forcats (variables qualitatives) stringr (chaînes de caractères) Il existe dautres extensions qui font partie du tidyverse mais qui doivent être chargées explicitement, comme par exemple readxl (pour limportation de données depuis des fichiers Excel). La liste complète des extensions se trouve sur le site officiel du tidyverse https://www.tidyverse.org/packages/. 2.3 Les tidy data Le tidyverse est en partie fondé sur le concept de tidy data, développé à lorigine par Hadley Wickham dans un article du Journal of Statistical Software, voir (Wickham 2014). Nous pourrions traduire ce concept par données bien rangées. Il sagit dun modèle dorganisation des données qui vise à faciliter le travail souvent long et fastidieux de nettoyage et de préparation préalable à la mise en oeuvre de méthodes danalyse. Dans ce livre, nous travaillerons toujours avec des tidy data. En réalité, la plupart des données rencontrées par les chercheurs ne sont pas tidy. Il existe une extension du tidyverse qui permet de faciliter la transformation de données non tidy en données tidy, lextension tidyr. Nous ne verrons pas comment lutiliser dans ce livre. Les principes dun jeu de données tidy sont les suivants : chaque variable est une colonne chaque observation est une ligne chaque valeur doit être dans une cellule différente La figure 2.1 montre ces règles de façon visuelle (limage a été prise de (Wickham and Grolemund 2017)). Figure 2.1: Suivre les trois principes rend les données tidy: les variables sont en colonnes, les observations sont sur des lignes, et chaques valeurs sont dans des cellules différentes. Pourquoi sassurer que vos données sont tidy? Il y a deux avantages importants: Un avantage général de choisir une seule façon de conserver vos données. Si vous utilisez une structure de données consitante, il est plus facile dapprendre à utiliser les outils qui fonctionneront avec ce type de structure, étant donné que celles-ci possède une uniformité sous-jacente. Un avantage spécifique de placer les variables en colonnes car ceci permet de vectoriser les opérations dans R. Ceci implique que vos fonctions seront plus rapides lorsque viendra le temps de les exécuter. Voici un exemple de données tidy qui sont accessibles en R de base. as_tibble(rownames_to_column(mtcars)) #&gt; # A tibble: 32 x 12 #&gt; rowname mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 Mazda RX4 W~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 Hornet 4 Dr~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 Hornet Spor~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with 26 more rows 2.4 Les tibbles Une autre particularité du tidyverse est que ces extensions travaillent avec des tableaux de données au format tibble, qui est une évolution plus moderne du classique data frame du R de base. Ce format est fourni est géré par lextension du même nom (tibble), qui fait partie du coeur du tidyverse. La plupart des fonctions des extensions du tidyverse acceptent des data frames en entrée, mais retournent un objet de classe tibble. Pour être en mesure deffectuer des calculs statistiques, il nous faut une structure qui soit en mesure de garder en mémoire une base de données. Ces structures se nomment des tibbles dans R. 2.4.1 Prérequis Pour être en mesure dutiliser le paquetage tibble, nous devons charger lextension tibble. Pour ce faire, il suffit dutiliser la commande suivante: library(tibble) 2.4.2 Un exemple de tibble Pour comprendre ce quest un tibble, nous allons utiliser deux librairies: nycflights13 et diamonds. Si ce nest pas déjà fait, vous devez les installer et ensuite les charger. library(nycflights13) #&gt; Warning: le package &#39;nycflights13&#39; a été compilé avec la version R 4.0.5 library(ggplot2) Nous allons étudier le paquetage nycflights13qui contient 5 bases de données contenant des informations concernant les vols intérieurs en partance de New York en 2013, à partir des aéroports de Newark Liberty International (EWR), John F. Kennedy International (JFK) ou LaGuardia (LGA). Les 5 bases de données sont les suivantes: flights: information sur les 336,776 vols airlines: lien entre les codes IATA de deux lettres et les noms de compagnies daviation (16 au total) planes: information de construction sur les 3 322 avions utilisés weather: données météo à chaque heure (environ 8 710 observations) pour chacun des trois aéroports. airports: noms des aéroports et localisations 2.4.3 La base de données flights Pour visualiser facilement une base de données sous forme tibble, il suffit de taper son nom dans la console. Nous allons utiliser la base de données flights. Par exemple: flights #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Nous allons décortiquer la sortie console: A tibble: 336,776 x 19: un tibble est une façon de représenter une base de données en R. Cette base de données possède: 336 776 lignes 19 colonnes correspondant aux 19 variables décrivant chacune des observations year month day dep_time sched_dep_time dep_delay arr_time sont différentes colonnes, en dautres mots des variables, de cette base de données. Nous avons ensuite 10 lignes dobervations correspondant à 10 vols ... with 336,766 more rows, and 12 more variables: nous indique que 336 766 lignes et 12 autres variables ne pouvaient pas être affichées à lécran. Malheureusement cette sortie écran ne nous permet pas dexplorer les données correctement. Nous verrons à la section 2.4.5 comment explorer des tibbles. 2.4.4 La base de données diamonds La base de données diamonds est composée des variables suivantes: price : prix en dollars US carat : poids du diamant en grammes cut : qualité de la coupe (Fair, Good, Very Good, Premium, Ideal) color : couleur du diamant (J (pire) jusquà D (meilleur)) clarity : une mesure de la clarté du diamant (I1 (pire), SI2, SI1, VS2, VS1, VVS2, VVS1, IF (meilleur)) x : longueur en mm y : largeur en mm z : hauteur en mm depth : z / mean(x, y) = 2 * z / (x + y) table : largeur du dessus du diamant par rapport à son point le plus large diamonds #&gt; # A tibble: 53,940 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 #&gt; 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 #&gt; 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 #&gt; 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 #&gt; 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 #&gt; 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 #&gt; # ... with 53,934 more rows 2.4.5 Comment explorer des tibbles Voici les façons les plus communes de comprendre les données se trouvant à lintérieur dun tibble: 1. En utilisant la fonction `View()` de RStudio.C&#39;est la commande que nous utiliserons le plus fr?quemment. 2. En utilisant la fonction `glimpse()` du paquetage knitr 3. En utilisant la fonction `kable()` 4. En utilisant l&#39;opérateur `$` pour étudier une seule variable d&#39;une base de données View(): Éxécutez View(flights) dans la console de RStudio et explorez la base de données obtenue. Nous remarquons que chaque colonnes représentent une variable différente et que ces variables peuvent être de différents types. Certaines de ces variables, comme distance, day et arr_delay sont des variables dites quantitatives. Ces variables sont numériques par nature. Dautres variables sont dites qualitatives. Si vous regardez la colonne à lextrème-gauche de la sortie de View(flights), vous verrez une colonne de nombres. Ces nombres représentent les numéros de ligne de la base de données. Si vous vous promenez sur une ligne de même nombre, par exemple la ligne 5, vous étudiez une unité statistique. glimpse: La seconde façon dexplorer une base de données est dutiliser la fonction glimpse(). Cette fonction nous donne la majorité de linformation précédente et encore plus. glimpse(flights) #&gt; Rows: 336,776 #&gt; Columns: 19 #&gt; $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2~ #&gt; $ month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~ #&gt; $ day &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~ #&gt; $ dep_time &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, ~ #&gt; $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, ~ #&gt; $ dep_delay &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1~ #&gt; $ arr_time &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,~ #&gt; $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,~ #&gt; $ arr_delay &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1~ #&gt; $ carrier &lt;chr&gt; &quot;UA&quot;, &quot;UA&quot;, &quot;AA&quot;, &quot;B6&quot;, &quot;DL&quot;, &quot;UA&quot;, &quot;B6&quot;, &quot;EV&quot;, &quot;B6&quot;, &quot;~ #&gt; $ flight &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4~ #&gt; $ tailnum &lt;chr&gt; &quot;N14228&quot;, &quot;N24211&quot;, &quot;N619AA&quot;, &quot;N804JB&quot;, &quot;N668DN&quot;, &quot;N394~ #&gt; $ origin &lt;chr&gt; &quot;EWR&quot;, &quot;LGA&quot;, &quot;JFK&quot;, &quot;JFK&quot;, &quot;LGA&quot;, &quot;EWR&quot;, &quot;EWR&quot;, &quot;LGA&quot;,~ #&gt; $ dest &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;MIA&quot;, &quot;BQN&quot;, &quot;ATL&quot;, &quot;ORD&quot;, &quot;FLL&quot;, &quot;IAD&quot;,~ #&gt; $ air_time &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1~ #&gt; $ distance &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, ~ #&gt; $ hour &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6~ #&gt; $ minute &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0~ #&gt; $ time_hour &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0~ kable(): La dernière façon détudier lentièreté de la base de données est dutiliser la fonction kable() de la librairie knitr. Nous allons explorer les codes des différentes compagnies daviation de deux façons. library(knitr) airlines #&gt; # A tibble: 16 x 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 9E Endeavor Air Inc. #&gt; 2 AA American Airlines Inc. #&gt; 3 AS Alaska Airlines Inc. #&gt; 4 B6 JetBlue Airways #&gt; 5 DL Delta Air Lines Inc. #&gt; 6 EV ExpressJet Airlines Inc. #&gt; # ... with 10 more rows kable(airlines) carrier name 9E Endeavor Air Inc. AA American Airlines Inc. AS Alaska Airlines Inc. B6 JetBlue Airways DL Delta Air Lines Inc. EV ExpressJet Airlines Inc. F9 Frontier Airlines Inc. FL AirTran Airways Corporation HA Hawaiian Airlines Inc. MQ Envoy Air OO SkyWest Airlines Inc. UA United Air Lines Inc. US US Airways Inc. VX Virgin America WN Southwest Airlines Co. YV Mesa Airlines Inc. À première vue, les deux sorties sont semblables sauf que la seconde est beaucoup plus agréable visuellement dans un document R Markdown. Lopérateur $: Finalement, lopérateur $ nous permet dexplorer une seule variable à lintérieur dune base de données. Par exemple, si nous désirons étudier la variable name de la base de données airlines, nous obtenons: airlines$name #&gt; [1] &quot;Endeavor Air Inc.&quot; &quot;American Airlines Inc.&quot; #&gt; [3] &quot;Alaska Airlines Inc.&quot; &quot;JetBlue Airways&quot; #&gt; [5] &quot;Delta Air Lines Inc.&quot; &quot;ExpressJet Airlines Inc.&quot; #&gt; [7] &quot;Frontier Airlines Inc.&quot; &quot;AirTran Airways Corporation&quot; #&gt; [9] &quot;Hawaiian Airlines Inc.&quot; &quot;Envoy Air&quot; #&gt; [11] &quot;SkyWest Airlines Inc.&quot; &quot;United Air Lines Inc.&quot; #&gt; [13] &quot;US Airways Inc.&quot; &quot;Virgin America&quot; #&gt; [15] &quot;Southwest Airlines Co.&quot; &quot;Mesa Airlines Inc.&quot; "],["lextension-questionr.html", "Chapitre 3 Lextension questionr 3.1 Mise en place 3.2 Linterface graphique", " Chapitre 3 Lextension questionr Lextension questionr propose une interface graphique pour faciliter lopération qui consiste à réordonner vos données. 3.1 Mise en place Pour installer lextension, vous effectuez la commande suivante: install.packages(&quot;questionr&quot;) Vous pouvez ensuite la charger. library(questionr) #&gt; Warning: `as.tibble()` was deprecated in tibble 2.0.0. #&gt; Please use `as_tibble()` instead. #&gt; The signature and semantics have changed, see `?as_tibble`. 3.2 Linterface graphique Lobjectif est de permettre à lutilisateur de saisir les nouvelles valeurs dans un formulaire, et de générer ensuite le code R correspondant au recodage indiqué. Pour utiliser cette interface, sous RStudio vous pouvez aller dans le menu Addins (présent dans la barre doutils principale) puis choisir Levels recoding. Figure 3.1: Levels recoding dans le menu Addins Si nous utilisons linterface graphique pour la variable rincome de la base de données gts_cat, nous obtenons: Figure 3.2: Linterface graphique de Levels recoding Linterface se compose de trois onglets : longlet Variable et paramètres vous permet de sélectionner la variable à recoder, le nom de la nouvelle variable et dautres paramètres, longlet Recodages vous permet de saisir les nouvelles valeurs des modalités, et longlet Code et résultat affiche le code R correspondant ainsi quun tableau permettant de vérifier les résultats. Une fois votre recodage terminé, cliquez sur le bouton Done et le code R sera inséré dans votre script R ou affiché dans la console. Important: cette interface est prévue pour ne pas modifier vos données. Cest donc à vous dexécuter le code généré pour que le recodage soit réellement effectif. "],["demarchescientifique.html", "Chapitre 4 La démarche scientifique", " Chapitre 4 La démarche scientifique La démarche scientifique permet détudier une problématique de sorte que les résultats obtenus soient valides et reproductibles. La démarche scientifique se divise en quatre étapes : Formulation dun sujet de recherche et méthodologie Recherche documentaire Formulation dhypothèses Détermination de la population et/ou de léchantillon Collecte des données Traitement des données et analyse des résultats Présentation des données Calculs de mesures Inférence statistique Diffusion des résultats Le cours de méthodes quantitatives porte entre autres sur les trois premières étapes. Une fois le sujet de recherche choisi, il faut décider comment la recherche sera menée, cest-à-dire établir la méthodologie. Pour ce faire, il faut dabord déterminer sil est préférable deffectuer un recensement (étude portant sur lensemble de la population) ou un sondage (étude portant sur une partie de la population). Il existe des avantages et des inconvénients à faire un recensement. |:|:| | Avantages | Les résultats obtenus correspondent exactement à la réalité. Il est aisé danalyser des sous-ensembles de la population.| | Inconvénients | Les coûts sont élevés.Les résultats sont longs à obtenir.| Puisquil est généralement souhaitable que la récolte dinformation soit faite à coûts moindres et le plus rapidement possible, le sondage est souvent utilisé. Ensuite, le chercheur doit définir les éléments suivants : |:|:| | La population | Ensemble des personnes, faits ou objets sur lesquels porte létude.Sa taille est notée \\(N\\)| | Lunité statistique | Une personne, fait ou objet de la population.| | Léchantillon | Sous-ensemble de la population utilisé lors dun sondage. Sa taille est notée \\(n\\).| Dans le choix de la méthodologie, il est aussi important de déterminer les variables étudiées, le type des variables, les échelles de mesure, les types de questions et les techniques déchantillonnage. Ceux-ci seront étudiés dans les chapitres suivants. "],["typesvariables.html", "Chapitre 5 Les différents types de variables 5.1 Introduction 5.2 Les variables qualitatives 5.3 Les variables quantitatives", " Chapitre 5 Les différents types de variables 5.1 Introduction Chacune des notions étudiées par le chercheur porte le nom de variable. Cest logique, puisque les données recueillies vont varier dune unité statistique à une autre. On distingue quatre types de variables séparées en deux grandes catégories : les variables qualitatives et les variables quantitatives. 5.1.1 Mise en place Dans ce chapitre, nous introduirons les différents types de variables et les façons avec lesquelles nous pouvons les utiliser en langage R. Nous utiliserons la librairie tidyverse et en particulier lextension forcats pour travailler avec des variables qualitatives. Puisque lextension forcats fait partie du tidyverse de base, nous avons simplement à charger tidyverse. library(tidyverse) 5.2 Les variables qualitatives Une variable qualitative est une variable dont les résultats possibles sont des mots. Les différents mots que peuvent prendre une telle variable sont appelées des modalités. Il existe deux types de variables qualitatives. 5.2.1 Les variables qualitatives à échelle nominale On observe ce type de variable lorsquil ny a pas dordre croissant naturel dans les modalités de la variable. Par exemple, la variable couleur des cheveux est à échelle nominale. Lordre blonds, bruns, roux, noirs, autre est un ordre aussi valable que bruns, noirs, roux, blonds, autre. Imaginons que vous vouliez créer une variable qui indique le mois de lannée: x1 &lt;- c(&quot;Déc&quot;, &quot;Avr&quot;, &quot;Jan&quot;, &quot;Mar&quot;) Lapproche précédente pose deux problèmes: Il ny a que douze mois possibles et rien ne vous empêche de vous tromper dans votre entrée de modalités: x2 &lt;- c(&quot;Déc&quot;, &quot;Avr&quot;, &quot;Jam&quot;, &quot;Mar&quot;) Les modalités ne seront pas affichées dans un ordre logique # La commande &quot;sort&quot; permet de trier les données sort(x1) #&gt; [1] &quot;Avr&quot; &quot;Déc&quot; &quot;Jan&quot; &quot;Mar&quot; Nous pouvons résoudre ce problèmes en utilisant un facteur (factor en R). Pour créer un facteur, vous devez créer en premier lieu une liste avec toutes les modalités possibles placées dans lordre qui vous convient (levels en R): niveaux_mois &lt;- c( &quot;Jan&quot;, &quot;Fév&quot;, &quot;Mar&quot;, &quot;Avr&quot;, &quot;Mai&quot;, &quot;Jun&quot;, &quot;Jui&quot;, &quot;Aoû&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Déc&quot; ) Vous pouvez maintenant créer un facteur: y1 &lt;- factor(x1, levels = niveaux_mois) y1 #&gt; [1] Déc Avr Jan Mar #&gt; Levels: Jan Fév Mar Avr Mai Jun Jui Aoû Sep Oct Nov Déc sort(y1) #&gt; [1] Jan Mar Avr Déc #&gt; Levels: Jan Fév Mar Avr Mai Jun Jui Aoû Sep Oct Nov Déc Si certaines modalités ne sont pas dans votre liste de levels, elles seront converties en NA: y2 &lt;- factor(x2, levels = niveaux_mois) y2 #&gt; [1] Déc Avr &lt;NA&gt; Mar #&gt; Levels: Jan Fév Mar Avr Mai Jun Jui Aoû Sep Oct Nov Déc Si vous nutilisez pas vos levels, vos modalités seront affichées en ordre alphabétique: factor(x1) #&gt; [1] Déc Avr Jan Mar #&gt; Levels: Avr Déc Jan Mar Le fait quil y ait un ordre dans les modalités nest pas suffisant pour dire quune variable qualitative nest pas nominale. Dans lexemple précédent, bien que les mois de lannée soient toujours énumérés dans un certain ordre, il serait faux de dire que Janvier &lt; Février par exemple. Nous pourrions créer une variable qui contient la couleur des cheveux sans indiquer de levels. De cette façon, les données seront triées en ordre alphabétique: x3 &lt;- c(&quot;blonds&quot;, &quot;bruns&quot;, &quot;roux&quot;, &quot;noirs&quot;, &quot;autre&quot;) sort(x3) #&gt; [1] &quot;autre&quot; &quot;blonds&quot; &quot;bruns&quot; &quot;noirs&quot; &quot;roux&quot; Nous allons maintenant utiliser de vraies données provenant du General Social Survey, qui est un sondage produit par une organisation de recherche indépendante NORC à lUniversité de Chicago. Le sondage original comporte des milliers de questions, la base de donnéee forcats::gss_cat nen contient que quelques unes. Pour en savoir plus sur la base de données gss_cat, consultez Wickham (2021a). gss_cat #&gt; # A tibble: 21,483 x 9 #&gt; year marital age race rincome partyid relig denom tvhours #&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 2000 Never mar~ 26 White $8000 to ~ Ind,near r~ Protesta~ Souther~ 12 #&gt; 2 2000 Divorced 48 White $8000 to ~ Not str re~ Protesta~ Baptist~ NA #&gt; 3 2000 Widowed 67 White Not appli~ Independent Protesta~ No deno~ 2 #&gt; 4 2000 Never mar~ 39 White Not appli~ Ind,near r~ Orthodox~ Not app~ 4 #&gt; 5 2000 Divorced 25 White Not appli~ Not str de~ None Not app~ 1 #&gt; 6 2000 Married 25 White $20000 - ~ Strong dem~ Protesta~ Souther~ NA #&gt; # ... with 21,477 more rows Pour visualiser les levels dune variable facilement, nous pouvons utiliser la fonction levels qui retourne tous les levels différents rencontrés pour cette variable. Voici par exemple les levels pour les variables race et marital levels(gss_cat$race) #&gt; [1] &quot;Other&quot; &quot;Black&quot; &quot;White&quot; &quot;Not applicable&quot; levels(gss_cat$marital) #&gt; [1] &quot;No answer&quot; &quot;Never married&quot; &quot;Separated&quot; &quot;Divorced&quot; #&gt; [5] &quot;Widowed&quot; &quot;Married&quot; 5.2.2 Les variables qualitatives à échelle ordinale On observe ce type de variable lorsquil existe un ordre croissant dans les modalités de la variable. Par exemple, la variable degré de satisfaction est à échelle ordinale. Il est possible de classer les modalités en ordre décroissant en écrivant : Très satisfait &gt; Satisfait &gt; Insatisfait &gt; Très insatisfait. Pour créer une variable qualitative à échelle ordinale en R, nous pouvons utiliser la même technique vue à la section 5.2.1. Nous pouvons donc avoir: z &lt;- c(&quot;Satisfait&quot;, &quot;Très insatisfait&quot;, &quot;Insatisfait&quot;, &quot;Très insatisfait&quot;, &quot;Insatisfait&quot;) niveaux_satisfaction &lt;- c(&quot;Très insatisfait&quot;, &quot;Insatisfait&quot;, &quot;Satisfait&quot;, &quot;Très satisfait&quot;) z1 &lt;- factor(z, levels = niveaux_satisfaction) sort(z1) #&gt; [1] Très insatisfait Très insatisfait Insatisfait Insatisfait #&gt; [5] Satisfait #&gt; Levels: Très insatisfait Insatisfait Satisfait Très satisfait Il est aussi possible dutiliser des facteurs ordonnés. Nous devons utiliser encore la commande factor en ajoutant loption ordered=TRUE. Par example: z2 &lt;- factor(z, levels = niveaux_satisfaction, ordered = TRUE) sort(z2) #&gt; [1] Très insatisfait Très insatisfait Insatisfait Insatisfait #&gt; [5] Satisfait #&gt; Levels: Très insatisfait &lt; Insatisfait &lt; Satisfait &lt; Très satisfait Remarquons que dans la liste Levels, R ajoute les symboles &lt; pour indiquer que la variable possède un ordre. Il nest pas nécessaire de travailler avec des facteurs ordonnés. Nous remarquons que dans la base de données forcats::gss_cat, la variable rincome représente une variable qualitative à échelle ordinale: levels(gss_cat$rincome) #&gt; [1] &quot;No answer&quot; &quot;Don&#39;t know&quot; &quot;Refused&quot; &quot;$25000 or more&quot; #&gt; [5] &quot;$20000 - 24999&quot; &quot;$15000 - 19999&quot; &quot;$10000 - 14999&quot; &quot;$8000 to 9999&quot; #&gt; [9] &quot;$7000 to 7999&quot; &quot;$6000 to 6999&quot; &quot;$5000 to 5999&quot; &quot;$4000 to 4999&quot; #&gt; [13] &quot;$3000 to 3999&quot; &quot;$1000 to 2999&quot; &quot;Lt $1000&quot; &quot;Not applicable&quot; Si nous laissons de côté les modalités No answer, Dont know et Refused, le reste des modalités peut être placé en ordre. En effet, la modalité $4000 to 4999 est plus petite que la modalité $5000 to 5999 et ainsi de suite. Bien que les modalités de la variable précédente soient composées de nombres, le fait que nous ayons affaire à des intervalles indique que nous avons en fait une variable qualitative à échelle ordinale. Les modalités sont placées en ordre décroissant, si nous voulions avoir les modalités en ordre croissant, nous pourrions faire ceci: a &lt;- factor(gss_cat$rincome, levels=c(&quot;Lt $1000&quot;, &quot;$1000 to 2999&quot;, &quot;$3000 to 3999&quot;, &quot;$4000 to 4999&quot;, &quot;$5000 to 5999&quot;, &quot;$6000 to 6999&quot;, &quot;$7000 to 7999&quot;, &quot;$8000 to 9999&quot;, &quot;$10000 - 14999&quot;, &quot;$15000 - 19999&quot;, &quot;$20000 - 24999&quot;, &quot;$25000 or more&quot;, &quot;No answer&quot;, &quot;Refused&quot;, &quot;Not applicable&quot;, &quot;Don&#39;t know&quot;)) levels(a) #&gt; [1] &quot;Lt $1000&quot; &quot;$1000 to 2999&quot; &quot;$3000 to 3999&quot; &quot;$4000 to 4999&quot; #&gt; [5] &quot;$5000 to 5999&quot; &quot;$6000 to 6999&quot; &quot;$7000 to 7999&quot; &quot;$8000 to 9999&quot; #&gt; [9] &quot;$10000 - 14999&quot; &quot;$15000 - 19999&quot; &quot;$20000 - 24999&quot; &quot;$25000 or more&quot; #&gt; [13] &quot;No answer&quot; &quot;Refused&quot; &quot;Not applicable&quot; &quot;Don&#39;t know&quot; 5.3 Les variables quantitatives Une variable quantitative est une variable dont les résultats possibles sont des nombres. Les différents nombres que peuvent prendre une telle variable sont appelées des valeurs. 5.3.1 Mise en place Dans cette section, nous utiliserons la librairie nycflights13 (voir Wickham (2021b)) qui contient cinq bases de données portant sur tous les vols aériens ayant quittés la ville de New-York en 2013. library(nycflights13) Les cinq base de données sont les suivantes: airlines airports flights planes weather Pour en savoir plus sur une base de données particulière, par exemple airlines vous pouvez utilisez la commande ?airlines. 5.3.2 Les variables quantitatives discrètes On observe ce type de variable lorsque les valeurs sont énumérables, cest-à-dire lorsquil nexiste pas de valeur possible entre deux valeurs consécutives. Par exemple, la variable nombre de cours suivis pendant cette session est une variable quantitative discrète. Les valeurs de ces variables peuvent être : 3, 4, 5, 6, 7, Il est impossible de suivre 4,6 cours durant une session. La base de données planes contient certaines variables quantitatives discrètes. planes #&gt; # A tibble: 3,322 x 9 #&gt; tailnum year type manufacturer model engines seats speed engine #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 N10156 2004 Fixed wing mu~ EMBRAER EMB-1~ 2 55 NA Turbo-~ #&gt; 2 N102UW 1998 Fixed wing mu~ AIRBUS INDUST~ A320-~ 2 182 NA Turbo-~ #&gt; 3 N103US 1999 Fixed wing mu~ AIRBUS INDUST~ A320-~ 2 182 NA Turbo-~ #&gt; 4 N104UW 1999 Fixed wing mu~ AIRBUS INDUST~ A320-~ 2 182 NA Turbo-~ #&gt; 5 N10575 2002 Fixed wing mu~ EMBRAER EMB-1~ 2 55 NA Turbo-~ #&gt; 6 N105UW 1999 Fixed wing mu~ AIRBUS INDUST~ A320-~ 2 182 NA Turbo-~ #&gt; # ... with 3,316 more rows Pour être en mesure de connaître toutes les valeurs différentes que peut prendre une variable, nous allons utiliser la commande unique. Si nous nous intéressons à la variable engines (qui dénombre le nombre de moteurs de lavion): unique(planes$engines) #&gt; [1] 2 1 4 3 Les avions peuvent donc avoir 1, 2, 3 ou 4 moteurs. La variable seats (qui dénombre le nombre de sièges de lavion): unique(planes$seats) #&gt; [1] 55 182 149 330 178 95 290 199 20 140 2 8 400 260 255 191 375 145 22 #&gt; [20] 14 6 80 189 7 4 377 102 10 11 269 200 222 172 379 5 147 100 16 #&gt; [39] 275 292 139 9 450 179 128 300 142 12 Dans la sortie R les valeurs ne sont pas en ordre croissant mais elles le seront lorsque nous les représenterons sous forme de tableau ou de graphique. Bien que la variable seats possède plusieurs valeurs (elle en possède 48), cela ne signifie pas quelle soit une variable quantitative continue, comme nous le verrons à la section 5.3.3. 5.3.3 Les variables quantitatives continues On observe ce type de variable lorsquil existe une infinité de valeurs entre deux autres. Par exemple, la variable masse dun étudiant (en lbs) est une variable quantitative continue. Entre 130 et 131 lbs, il existe une infinité de valeurs telles que 130,54 lbs. Dans la base de données weather de lextension nycflights13, nous allons observer la variable temp, qui représente la température en degrés Farenheit pour toutes les heures de chaques jours de lannée 2013. weather #&gt; # A tibble: 26,115 x 15 #&gt; origin year month day hour temp dewp humid wind_dir wind_speed wind_gust #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 EWR 2013 1 1 1 39.0 26.1 59.4 270 10.4 NA #&gt; 2 EWR 2013 1 1 2 39.0 27.0 61.6 250 8.06 NA #&gt; 3 EWR 2013 1 1 3 39.0 28.0 64.4 240 11.5 NA #&gt; 4 EWR 2013 1 1 4 39.9 28.0 62.2 250 12.7 NA #&gt; 5 EWR 2013 1 1 5 39.0 28.0 64.4 260 12.7 NA #&gt; 6 EWR 2013 1 1 6 37.9 28.0 67.2 240 11.5 NA #&gt; # ... with 26,109 more rows, and 4 more variables: precip &lt;dbl&gt;, #&gt; # pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt; Si nous utilisons la commande unique sur cette variable, nous obtenons la sortie suivante: unique(weather$temp) #&gt; [1] 39.0 39.9 37.9 41.0 39.2 37.0 36.0 34.0 33.1 32.0 30.0 28.9 #&gt; [13] 28.0 27.0 26.1 25.0 24.1 30.9 35.1 42.1 43.0 44.1 33.8 37.4 #&gt; [25] 46.0 46.9 48.0 45.0 48.9 50.0 46.4 44.6 48.2 51.1 51.8 52.0 #&gt; [37] 53.6 55.9 57.9 57.0 55.0 53.1 35.6 54.0 23.0 21.0 19.9 21.9 #&gt; [49] 19.0 18.0 17.1 16.0 15.1 14.0 12.9 12.0 10.9 21.2 19.4 30.2 #&gt; [61] 42.8 64.0 64.4 59.0 60.8 62.1 62.6 57.2 24.8 28.4 41.9 45.7 #&gt; [73] 41.2 38.8 34.2 34.9 32.4 36.5 60.1 63.0 64.9 66.0 70.0 71.1 #&gt; [85] 68.0 66.9 73.9 77.0 80.1 82.0 82.9 84.0 81.0 79.0 73.0 69.1 #&gt; [97] 61.0 72.0 66.2 73.4 75.2 75.9 55.4 78.1 69.8 75.0 86.0 88.0 #&gt; [109] 87.1 84.9 78.8 82.4 89.1 91.0 91.9 93.0 91.4 90.0 71.6 93.9 #&gt; [121] 89.6 80.6 95.0 87.8 84.2 97.0 96.1 98.1 100.0 99.0 93.2 NA #&gt; [133] 47.5 50.7 47.1 50.5 49.1 47.3 51.3 26.6 45.3 13.1 82.6 84.7 #&gt; [145] 83.7 81.1 54.5 53.4 50.2 48.4 43.2 40.6 42.3 43.9 47.8 52.5 #&gt; [157] 55.6 54.1 54.9 50.9 51.4 49.5 46.6 49.8 50.4 52.7 56.5 58.1 #&gt; [169] 57.6 51.6 60.4 60.3 59.2 55.8 Puisque nous avons 174 températures différentes et que nous avons affaire à une variable quantitative continue, il est souvent avantageux de placer ces données dans des classes. Nous verrons comment faire au chapitre 11. "],["questionnaire.html", "Chapitre 6 Construire un questionnaire 6.1 Critères à respecter 6.2 Types de questions", " Chapitre 6 Construire un questionnaire La deuxième étape de la démarche scientifique est la récolte des données. La façon la plus simple de faire est sans nul doute lutilisation du questionnaire. Lors de la conception dun questionnaire, il est important de choisir les questions de façon à obtenir linformation recherchée. 6.1 Critères à respecter Pour construire un questionnaire qui est fiable, il existe des règles à suivre. Les questions doivent posséder les qualités ci-dessous : Claire Complète Neutre Non-menaçante Pertinente 6.2 Types de questions Deux questions portant sur un même sujet ne donnent pas nécessairement la même information. Cest pourquoi il est extrêmement important de bien choisir les questions lorsquun questionnaire est construit. Pour plus dinformation à ce sujet, consultez le chapitre 7 portant sur les échelles de mesure. 6.2.1 Question ouverte Ce type de question ne limite pas les réponses. On lutilise principalement pour récolter lopinion des gens. 6.2.2 Questions fermées Ces questions restreignent les choix des répondants. Réponse brève : la réponse est une lettre, un chiffre ou un mot Dichotomique : il ny a que deux choix de réponses Choix multiples : le répondant doit sélectionner une réponse parmi celles proposées Cafétéria : plusieurs réponses parmi celles proposées peuvent être choisies Nature hiérarchique : des éléments doivent être placés en ordre dimportance "],["echellesmesures.html", "Chapitre 7 Les échelles de mesure", " Chapitre 7 Les échelles de mesure "],["techniquesechantillonnage.html", "Chapitre 8 Les techniques déchantillonnage 8.1 Techniques déchantillonnage aléatoires 8.2 Techniques déchantillonnage non-aléatoires 8.3 Base de données pour les M&amp;Ms", " Chapitre 8 Les techniques déchantillonnage Lorsquon souhaite effectuer un sondage plutôt quun recensement, il existe diverses façons pour déterminer quelles seront les n unités statistiques qui feront partie de léchantillon. Celles-ci sont appelées techniques déchantillonnage. 8.1 Techniques déchantillonnage aléatoires Ces techniques permettent de choisir \\(n\\) unités statistiques au hasard parmi la population. En choisissant une de ces techniques, il est possible de tirer des conclusions sur une population à partir des résultats dun sondage puisque la marge derreur peut être calculée. Ces techniques nécessitent par contre une base de sondage, cest-à-dire une liste de toutes les unités statistiques. Il existe 4 techniques déchantillonnage aléatoires. Simple: Les individus sont choisis aléatoirement parmi toutes les unités statistiques. Stratifié: La population est divisée en sous-ensembles ayant des caractéristiques communes (strates), puis des unités statistiques sont choisies parmi chacune des strates de façon aléatoire en respectant les proportions de la population. Par grappes: La population est divisée en sous-ensembles préalablement existants (grappes). Des grappes sont sélectionnées aléatoirement et toutes les unités statistiques de ces grappes sont choisies. Systématique: Les unités statistiques sont choisies à intervalles réguliers. Le pas de sondage, lintervalle auquel sont choisies les unités statistiques, est \\(p=\\frac{N}{n}\\). La première unité statistique est choisie aléatoirement parmi les p premières unités statistiques. 8.2 Techniques déchantillonnage non-aléatoires Ces techniques déchantillonnage ne relèvent pas du hasard, mais elles sont souvent utilisées puisquelles ne nécessitent pas de base de sondage et sont par le fait même généralement plus faciles à mettre en application. Accidentel/À laveuglette: Les unités statistiques sont choisies parce quelles sont présentes lorsque le sondage est effectué. Volontaire: Les unités statistiques décident elles-mêmes de participer au sondage. Par quotas: La population est divisée en sous-ensembles ayant des caractéristiques communes, puis des unités statistiques sont choisies parmi chacun des sous-ensembles de façon accidentelle en respectant les proportions de la population. Au jugé: Le chercheur choisit des unités statistiques précises parce quil croit quelles sont représentatives de la population. 8.3 Base de données pour les M&amp;Ms "],["variablesqualitatives.html", "Chapitre 9 Les variables qualitatives 9.1 Mise en place 9.2 Tableau de fréquences 9.3 Représentation graphique - Le diagramme à bandes", " Chapitre 9 Les variables qualitatives 9.1 Mise en place library(tidyverse) library(questionr) library(knitr) 9.2 Tableau de fréquences Une fois les données dun sondage recueillies, il est plus aisé danalyser ces données si elles sont classées dans un tableau. Le tableau de fréquences que nous utiliserons est le suivant: Titre Nom de la variable Nombre dunités statistiques Pourcentage dunités statistiques (%) (Modalités) (Fréquences absolues) (Fréquences relatives) Total n 100% Important : Le titre doit toujours être indiqué lors de la construction dun tableau de fréquence. Lorsque les données se trouvent dans une tibble dans R, il est possible dutiliser la commande freq de la librairie questionr pour afficher le tableau de fréquences. La commande freq prend comme argument la variable dont vous voulez produire le tableau de fréquences. Pour obtenir une sortie adéquate, il faut ajouter trois options à la commande: cum = FALSE; permet de ne pas afficher les pourcentages cumulés valid = FALSE; permet de ne pas afficher les données manquantes total = TRUE; permet dafficher le total Dans la base de données forcats::gss_cat, nous allons afficher la variable marital. Dans la commande ci-dessous, nous enregistrons le tableau de fréquences dans la variable tab_marital. Nous laffichons ensuite à laide de la commande kable. tab_marital &lt;- freq(gss_cat$marital, cum = FALSE, valid = FALSE, total = TRUE) kable(tab_marital) n % No answer 17 0.1 Never married 5416 25.2 Separated 743 3.5 Divorced 3383 15.7 Widowed 1807 8.4 Married 10117 47.1 Total 21483 100.0 À laide du tableau précédent, répondez aux questions suivantes: Combien de personnes ne se sont jamais mariées dans léchantillon? 5416 Quel est le pourcentage de personnes divorcées dans léchantillon? 15.7 % Quel est le nombre total dunités statistiques? 21483 Nous pouvons produire le tableau de fréquences de la variable race de la façon suivante: tab_race &lt;- freq(gss_cat$race, cum = FALSE, valid = FALSE, total = TRUE) kable(tab_race) n % Other 1959 9.1 Black 3129 14.6 White 16395 76.3 Not applicable 0 0.0 Total 21483 100.0 9.3 Représentation graphique - Le diagramme à bandes Pour représenter graphiquement les variables qualitatives, nous allons utiliser les diagrammes à bandes. Pour construire ce graphique: Chaque modalité est représentée par un rectangle. La hauteur de chaque rectangle doit être proportionnelle au nombre dunités statistiques (la fréquence absolue) OU au pourcentage dunités statistiques (la fréquence relative). Le titre et les fréquences (absolues ou relatives) doivent être indiqués. Laxe des x doit posséder un titre : le nom de la variable étudiée. Laxe des y doit posséder un titre : Nombre dunités statistiques ou Pourcentage dunités statistiques. La graduation de laxe des y doit commencer à zéro (laxe ne doit pas être coupé). Les rectangles doivent être équidistants et de largeur égale. De plus, ils ne doivent pas être collés. Pour produire le diagramme à bandes, nous utiliserons lextension ggplot2 qui est chargée avec le coeur de la librairie tidyverse. La grammaire graphique de ggplot2 peut être décrite de la façon suivante: A statistical graphic is a mapping of data variables to aesthetic attributes of geometric objects. Plus spécifiquement, nous pouvons briser un graphique en trois composantes essentielles: data: la base de données contenant les variables que nous désirons visualiser. geom: lobjet géométrique en question. Ceci réfère au type dobjet que nous pouvons observer dans notre graphique. Par exemple, des points, des lignes, des barres, etc. aes: les attributs esthétiques (aesthetics) de lobjet géométrique que nous affichons dans notre graphique. Par exemple, la position x/y, la couleur, la forme, la taille. Chaque attribut peut être associé à une variable dans notre base de données. 9.3.1 La variable marital Nous allons visualiser le diagramme à bandes de la variable marital provenant de la base de données forcats::gss_cat. Nous devons spécifier: data = gss_cat: la base de données. aes(x = marital): la variable étudiée. geom_bar(): nous voulons un diagramme à bandes La commande est donc: ggplot(data = gss_cat, aes(x = marital))+ geom_bar() Pour ajouter un titre et indiquer les titres des axes x et y, nous utilisons la commande labs (pour labels). ggplot(data = gss_cat, aes(x = marital))+ geom_bar()+ labs( title = &quot;Répartition de 21 483 personnes selon leur statut matrimonial&quot;, x = &quot;Statut matrimonial&quot;, y = &quot;Nombre d&#39;unités statistiques&quot; ) 9.3.2 La variable relig Nous pouvons afficher le diagramme à bandes horizontales de la variable relig en ajoutant la commande coord_flip(). Nous avons donc: ggplot(data = gss_cat, aes(x = relig))+ geom_bar()+ labs( title = &quot;Répartition de 21 483 personnes selon leur religion&quot;, x = &quot;Religion&quot;, y = &quot;Nombre d&#39;unités statistiques&quot; )+ coord_flip() "],["variablesquantitativesdiscretes.html", "Chapitre 10 Les variables quantitatives discrètes 10.1 Mise en place 10.2 Tableau de fréquences 10.3 Représentation graphique - Le diagramme à bandes", " Chapitre 10 Les variables quantitatives discrètes 10.1 Mise en place library(tidyverse) library(questionr) library(nycflights13) library(knitr) 10.2 Tableau de fréquences Une fois les données dun sondage recueillies, il est plus aisé danalyser ces données si elles sont classées dans un tableau. Le tableau de fréquences que nous utiliserons est le suivant : Titre Nom de la variable Nombre dunités statistiques Pourcentage dunités statistiques (%) Pourcentage cumulé (Valeurs) (Fréquences absolues) (Fréquences relatives) (Fréquences relatives cumulées) Total n 100% Le pourcentage cumulé permet de déterminer le pourcentage des répondants qui ont indiqué la valeur correspondante, ou une plus petite. Il sert à donner une meilleure vue densemble. Si pour la valeur \\(x_i\\) de la variable \\(A\\) la pourcentage cumulé est de \\(b\\) %, ceci signifie que \\(b\\) % des valeurs de la variable \\(A\\) sont plus petites ou égales à \\(x_i\\). La commande freq prend comme argument la variable dont vous voulez produire le tableau de fréquences. Pour obtenir une sortie adéquate, il faut ajouter trois options à la commande: cum = TRUE; permet dafficher les pourcentages cumulés valid = FALSE; permet de ne pas afficher les données manquantes total = TRUE; permet dafficher le total Dans la base de données nycflights13::planes, nous allons afficher la variable engines. Dans la commande ci-dessous, nous enregistrons le tableau de fréquences dans la variable tab_engines. Nous laffichons ensuite à laide de la commande kable. tab_engines &lt;- freq(planes$engines, cum = TRUE, valid = FALSE, total = TRUE) kable(tab_engines) n % %cum 1 27 0.8 0.8 2 3288 99.0 99.8 3 3 0.1 99.9 4 4 0.1 100.0 Total 3322 100.0 100.0 Nous remarquons que le pourcentage cumulé pour les avions possédant 3 moteurs est 99.9%. Quelle est la signification de ce pourcentage? Ceci signifie que 99.9% des avions possèdent 3 moteurs ou moins. Nous allons maintenant produire le tableau de fréquences de la variable tvhours de la base de données gss_cat. Cette variable correspond au nombre dheures de télévision écoutées par jour (pour avoir cette information, vous pouvez utiliser la commande ?forcats::gss_cat). Nous avons: tab_tvhours &lt;- freq(gss_cat$tvhours, cum = TRUE, valid = FALSE, total = TRUE) kable(tab_tvhours) n % %cum 0 675 3.1 3.1 1 2345 10.9 14.1 2 3040 14.2 28.2 3 1959 9.1 37.3 4 1408 6.6 43.9 5 695 3.2 47.1 6 478 2.2 49.3 7 119 0.6 49.9 8 262 1.2 51.1 9 19 0.1 51.2 10 122 0.6 51.8 11 9 0.0 51.8 12 96 0.4 52.3 13 9 0.0 52.3 14 24 0.1 52.4 15 17 0.1 52.5 16 10 0.0 52.5 17 2 0.0 52.5 18 7 0.0 52.6 20 14 0.1 52.6 21 2 0.0 52.7 22 2 0.0 52.7 23 1 0.0 52.7 24 22 0.1 52.8 NA 10146 47.2 100.0 Total 21483 100.0 100.0 Répondez aux questions suivantes: Quel est le pourcentage des répondants qui écoutent la télévision 3 heures par jour? 9.1 % Quel est le pourcentage des répondants qui écoutent la télévision 14 heures par jour? 0.1 % Peut-on croire le résultat pour le pourcentage de gens qui écoutent la télévision 24 heures par jour? Quelle est la signification du pourcentage cumulé pour 6 heures? Nous avons que 49.3 % des répondants écoutent la télévision 6 heures ou moins par jour. Quelle est la signification du pourcentage cumulé pour 7 heures? Nous avons que 49.9 % des répondants écoutent la télévision 7 heures ou moins par jour. Cest-à-dire quenviron la moitié des gens écoutent la télévision 7 heures ou moins par jour. Nous pouvons produire le tableau de fréquences de la variable seats de la façon suivante: tab_seats &lt;- freq(planes$seats, cum = TRUE, valid = FALSE, total = TRUE) kable(tab_seats) n % %cum 2 16 0.5 0.5 4 5 0.2 0.6 5 2 0.1 0.7 6 3 0.1 0.8 7 2 0.1 0.8 8 5 0.2 1.0 9 1 0.0 1.0 10 1 0.0 1.1 11 2 0.1 1.1 12 1 0.0 1.1 14 1 0.0 1.2 16 1 0.0 1.2 20 80 2.4 3.6 22 2 0.1 3.7 55 390 11.7 15.4 80 83 2.5 17.9 95 123 3.7 21.6 100 102 3.1 24.7 102 1 0.0 24.7 128 1 0.0 24.7 139 8 0.2 25.0 140 411 12.4 37.4 142 158 4.8 42.1 145 57 1.7 43.8 147 3 0.1 43.9 149 452 13.6 57.5 172 81 2.4 60.0 178 283 8.5 68.5 179 134 4.0 72.5 182 159 4.8 77.3 189 73 2.2 79.5 191 87 2.6 82.1 199 43 1.3 83.4 200 256 7.7 91.1 222 13 0.4 91.5 255 16 0.5 92.0 260 4 0.1 92.1 269 1 0.0 92.1 275 25 0.8 92.9 290 6 0.2 93.1 292 16 0.5 93.6 300 17 0.5 94.1 330 114 3.4 97.5 375 1 0.0 97.5 377 14 0.4 98.0 379 55 1.7 99.6 400 12 0.4 100.0 450 1 0.0 100.0 Total 3322 100.0 100.0 Comme nous pouvons le constater, le tableau est très grand car la variable seats possède 48 valeurs différentes. Nous allons donc parfois séparer nos valeurs en classes coomme nous le verrons au chapitre 11. Important! Au chapitre 5, nous avons étudié les différents types de variables. Parmi les variables quantitatives, nous avons distingué celles qui étaient discrètes de celles qui étaient continues.Bien que cela sapplique toujours, il est important de noter quune variable continue (par exemple, lâge) peut être traitée comme une variable discrète (puisque, de façon générale, les gens donnent un entier pour exprimer leur âge); de même, une variable discrète (par exemple, le revenu) peut être traitée comme une variable continue (puisque les différents revenus sont trop nombreux pour être énumérés). 10.3 Représentation graphique - Le diagramme à bandes Le graphique utilisé pour représenter une variable quantitative discrète est le diagramme à bâtons. Ce graphique est construit comme le diagramme à bandes rectangulaires verticales, sauf que les rectangles sont remplacés par des bâtons très minces (généralement une simple ligne). Pour modifier la largeur de vos lignes, vous utilisez loption width dans la commande geom_bar(). ggplot(data = planes, aes(x = engines))+ geom_bar(width = 0.1)+ labs( title = &quot;Répartition de 3 322 avions selon le nombre de leurs moteurs&quot;, x = &quot;Nombre de moteurs&quot;, y = &quot;Nombre d&#39;unités statistiques&quot; ) Vous pouvez produire un diagramme à bâtons horizontaux en utilisant la commande coord_flip(). ggplot(data = gss_cat, aes(x = tvhours))+ geom_bar(width = 0.1)+ labs( title = &quot;Répartition de 11 137 répondants selon le nombre d&#39;heures de télévision écoutées par jour&quot;, x = &quot;Nombre d&#39;heures de télévision&quot;, y = &quot;Nombre d&#39;unités statistiques&quot; )+ coord_flip() #&gt; Warning: Removed 10146 rows containing non-finite values (stat_count). "],["variablesquantitativescontinues.html", "Chapitre 11 Les variables quantitatives continues 11.1 Mise en place 11.2 Tableau de fréquences 11.3 Représentation graphique - Lhistogramme", " Chapitre 11 Les variables quantitatives continues 11.1 Mise en place library(tidyverse) library(questionr) library(nycflights13) library(knitr) 11.2 Tableau de fréquences Les différentes valeurs dune variable continue étant impossibles à énumérer, nous devrons regrouper celles-ci en classes. La première colonne sera donc constituée de celles-ci. Il sera parfois utile dajouter une colonne supplémentaire au tableau habituel: le milieu de classe. Celui-ci est calculé en faisant la moyenne entre le début de classe et la fin de classe. Le tableau de fréquences que nous utiliserons est le suivant : Titre Nom de la variable Nombre dunités statistiques Pourcentage dunités statistiques (%) Pourcentage cumulé (Classes) (Fréquences absolues) (Fréquences relatives) (Fréquences relatives cumulées) Total n 100% Pour être en mesure de briser une variable en classes, il faut utiliser la commande cut. Les options utilisées sont les suivantes: Pour ce faire, nous devons utiliser la commande cut qui permet dindiquer les frontières de ces classes. Voici un exemple où nous créons des classes de largeur 25: temp_classes &lt;- cut(weather$temp, breaks = c(0, 25, 50, 75, 100, 125), include.lowest = TRUE, right = FALSE) unique(temp_classes) #&gt; [1] [25,50) [0,25) [50,75) [75,100) [100,125] &lt;NA&gt; #&gt; Levels: [0,25) [25,50) [50,75) [75,100) [100,125] Nous nous retrouvons donc avec 6 classes. Lorsque nous présenterons les variables sous forme de tableau, il nous sera utile dutiliser la commande cut. Loption include.lowest indique que nous voulons conserver  Loption right = FALSE indique que nous voulons des intervalles fermés à gauche et ouverts à droite. include.lowest=TRUE: permet dinclure les valeurs extrèmes right=FALSE: permet davoir des classes fermées à gauche et ouvertes à droite breaks=c(0, 100, 200, 300, 400, 500, 600, 700): permet de couper les classes à 0, 100, 200, 300, 400, 500, 600 et 700 Pour simplifier le code, nous créons en premier lieu une variable air_time_rec avec les classes et nous laffichons ensuite avec freq. Remarquons que nous avons ajouté loption valid = TRUE car certaines valeurs sont manquantes. Rappelons que les données manquantes sont représentées par NA en R. Deux colonnes sont ajoutées: val%: le pourcentage en omettant les valeurs manquantes val%cum: le pourcentage cumulé en omettant les valeurs manquantes Nous obtenons donc: air_time_rec &lt;- cut(flights$air_time, include.lowest=TRUE, right=FALSE, breaks=c(0, 100, 200, 300, 400, 500, 600, 700)) tab_airtime &lt;- freq(air_time_rec, cum = TRUE, total = TRUE, valid = TRUE) kable(tab_airtime) n % val% %cum val%cum [0,100) 105687 31.4 32.3 31.4 32.3 [100,200) 146527 43.5 44.8 74.9 77.0 [200,300) 31036 9.2 9.5 84.1 86.5 [300,400) 43347 12.9 13.2 97.0 99.8 [400,500) 48 0.0 0.0 97.0 99.8 [500,600) 132 0.0 0.0 97.0 99.8 [600,700] 569 0.2 0.2 97.2 100.0 NA 9430 2.8 NA 100.0 NA Total 336776 100.0 100.0 100.0 100.0 À la section 10.2, nous avons vu que la variable seats de la base de données planes contenait 48 valeurs différentes. Nous allons donc créer le tableau de fréquences avec des classes. seats_rec &lt;- cut(planes$seats, include.lowest=TRUE, right=FALSE, breaks=c(0, 50, 100, 150, 200, 250, 300, 350, 400, 450)) tab_seats &lt;- freq(seats_rec, cum = TRUE, total = TRUE, valid = TRUE) kable(tab_seats) n % val% %cum val%cum [0,50) 122 3.7 3.7 3.7 3.7 [50,100) 596 17.9 17.9 21.6 21.6 [100,150) 1193 35.9 35.9 57.5 57.5 [150,200) 860 25.9 25.9 83.4 83.4 [200,250) 269 8.1 8.1 91.5 91.5 [250,300) 68 2.0 2.0 93.6 93.6 [300,350) 131 3.9 3.9 97.5 97.5 [350,400) 70 2.1 2.1 99.6 99.6 [400,450] 13 0.4 0.4 100.0 100.0 Total 3322 100.0 100.0 100.0 100.0 11.3 Représentation graphique - Lhistogramme ggplot(flights, aes(x = air_time))+ geom_histogram(binwidth = 50, center = 25, color = &#39;white&#39;)+ labs( title = &quot;Répartition de 327 346 vols selon le nombre de minutes de vol&quot;, x = &quot;Nombre de minutes de vol&quot;, y = &quot;Nombre d&#39;unités statistiques&quot; ) #&gt; Warning: Removed 9430 rows containing non-finite values (stat_bin). "],["deuxvariables.html", "Chapitre 12 Deux variables 12.1 Mise en place 12.2 Croisement de deux variables qualitatives 12.3 Croisement dune variable qualitative et dune variable quantitative 12.4 Croisement de deux variables quantitatives", " Chapitre 12 Deux variables 12.1 Mise en place library(tidyverse) library(questionr) library(knitr) 12.2 Croisement de deux variables qualitatives Quand on veut croiser deux variables qualitatives, on fait un tableau croisé. 12.2.1 Tableaux à double entrée Lorsque deux variables (peu importe leur type) sont étudiées simultanément, on construit un tableau à double entrée. Nom de la variable 2 Nom de la variable 1 (Modalités de la variable 2) Total (Modalités de la variable 1) (Fréquences) (Sous-totaux) Total (Sous-totaux) (Total) Nous utilisons la commande table à laquelle on passe cette fois deux variables en argument. Par exemple, en utilisant la base de données gss_cat, nous pouvons croiser les variables marital et race. table(gss_cat$marital,gss_cat$race) #&gt; #&gt; Other Black White Not applicable #&gt; No answer 2 2 13 0 #&gt; Never married 633 1305 3478 0 #&gt; Separated 110 196 437 0 #&gt; Divorced 212 495 2676 0 #&gt; Widowed 70 262 1475 0 #&gt; Married 932 869 8316 0 Nous pouvons exclure certaines modalités en utilisant loption exclude. Par exemple, on peut exclure les modalités Not applicable de la façon suivante: table(gss_cat$marital,gss_cat$race, exclude = c(&quot;Not applicable&quot;)) #&gt; #&gt; Other Black White #&gt; No answer 2 2 13 #&gt; Never married 633 1305 3478 #&gt; Separated 110 196 437 #&gt; Divorced 212 495 2676 #&gt; Widowed 70 262 1475 #&gt; Married 932 869 8316 Nous pouvons obtenir un tableau à double entrée comportant des pourcentages à laide de la commande prop. prop(table(gss_cat$marital,gss_cat$race)) #&gt; #&gt; Other Black White Total #&gt; No answer 0.0 0.0 0.1 0.1 #&gt; Never married 2.9 6.1 16.2 25.2 #&gt; Separated 0.5 0.9 2.0 3.5 #&gt; Divorced 1.0 2.3 12.5 15.7 #&gt; Widowed 0.3 1.2 6.9 8.4 #&gt; Married 4.3 4.0 38.7 47.1 #&gt; Total 9.1 14.6 76.3 100.0 Pour connaître toutes les options de la commande prop, vous pouvez utilisez la commande ?prop dans la console. Nous pouvons également obtenir les totaux des lignes et des colonnes en utilisant la commande addmargins: addmargins(table(gss_cat$marital,gss_cat$race)) #&gt; #&gt; Other Black White Not applicable Sum #&gt; No answer 2 2 13 0 17 #&gt; Never married 633 1305 3478 0 5416 #&gt; Separated 110 196 437 0 743 #&gt; Divorced 212 495 2676 0 3383 #&gt; Widowed 70 262 1475 0 1807 #&gt; Married 932 869 8316 0 10117 #&gt; Sum 1959 3129 16395 0 21483 Pour pouvoir interpréter ce tableau on doit passer du tableau en effectifs au tableau en pourcentages ligne ou colonne. Pour cela, on peut utiliser les fonctions lprop et cprop de lextension questionr, quon applique au tableau croisé précédent. Pour calculer des pourcentages lignes. lprop(table(gss_cat$marital,gss_cat$race)) #&gt; #&gt; Other Black White Total #&gt; No answer 11.8 11.8 76.5 100.0 #&gt; Never married 11.7 24.1 64.2 100.0 #&gt; Separated 14.8 26.4 58.8 100.0 #&gt; Divorced 6.3 14.6 79.1 100.0 #&gt; Widowed 3.9 14.5 81.6 100.0 #&gt; Married 9.2 8.6 82.2 100.0 #&gt; Ensemble 9.1 14.6 76.3 100.0 Pour calculer des pourcentages colonnes. cprop(table(gss_cat$marital,gss_cat$race)) #&gt; #&gt; Other Black White Ensemble #&gt; No answer 0.1 0.1 0.1 0.1 #&gt; Never married 32.3 41.7 21.2 25.2 #&gt; Separated 5.6 6.3 2.7 3.5 #&gt; Divorced 10.8 15.8 16.3 15.7 #&gt; Widowed 3.6 8.4 9.0 8.4 #&gt; Married 47.6 27.8 50.7 47.1 #&gt; Total 100.0 100.0 100.0 100.0 Comme vous pouvez le constater, les commandes lprop et cprop enlève les lignes ou colonnes dont la somme des effectifs est zéro. Pour empêcher ce comportement, vous devez utilisez loption drop = FALSE. Par exemple: lprop(table(gss_cat$marital,gss_cat$race), drop = FALSE) #&gt; #&gt; Other Black White Not applicable Total #&gt; No answer 11.8 11.8 76.5 0.0 100.0 #&gt; Never married 11.7 24.1 64.2 0.0 100.0 #&gt; Separated 14.8 26.4 58.8 0.0 100.0 #&gt; Divorced 6.3 14.6 79.1 0.0 100.0 #&gt; Widowed 3.9 14.5 81.6 0.0 100.0 #&gt; Married 9.2 8.6 82.2 0.0 100.0 #&gt; Ensemble 9.1 14.6 76.3 0.0 100.0 Pour connaître toutes les options de ces deux commandes, vous pouvez taper ?lprop ou ?cprop dans la console. 12.2.2 Représentation graphique - diagramme à bandes chevauchées Le graphique utilisé pour représenter simultanément deux variables qualitatives est le diagramme à bandes rectangulaires chevauchées. Ce graphique ressemble au diagramme à bandes rectangulaires verticales, à la différence quil y aura au moins deux rectangles pour chacune des modalités ainsi quune légende. Encore une fois, ce graphique peut être construit à partir des fréquences absolues ou relatives. Nous pouvons comparer les variable race et marital avec des diagrammes à bandes chevauchées en utilisant loption position = \"dodge\". ggplot(data = gss_cat, aes(x = race, fill = marital))+ geom_bar(position = &quot;dodge&quot;)+ labs(x = &quot;Race&quot;, y = &quot;Fréquence&quot;) 12.2.3 Représentation graphique - diagramme à bandes superposées Si nous nutilisons pas loption position = \"dodge\", nous obtenons des diagrammes à bandes superposées. ggplot(data = gss_cat, aes(x = race, fill = marital))+ geom_bar()+ labs(x = &quot;Race&quot;, y = &quot;Fréquence&quot;) Pour obtenir des diagrammes comportant des fréquences relatives, nous utilisons loption position = \"fill\". ggplot(data = gss_cat, aes(x = race, fill = marital))+ geom_bar(position = &quot;fill&quot;)+ labs(x = &quot;Race&quot;, y = &quot;Fréquence&quot;) 12.3 Croisement dune variable qualitative et dune variable quantitative 12.3.1 Représentation graphique - boîte à moustaches Croiser une variable quantitative et une variable qualitative, cest essayer de voir si les valeurs de la variable quantitative se répartissent différemment selon la catégorie dappartenance de la variable qualitative. Pour cela, lidéal est de commencer par une représentation graphique de type boîte à moustache. Linterprétation dune boîte à moustaches est la suivante : Les bords inférieurs et supérieurs du carré central représentent le premier et le troisième quartile de la variable représentée sur laxe vertical. On a donc 50% de nos observations dans cet intervalle. Le trait horizontal dans le carré représente la médiane. Enfin, des moustaches sétendent de chaque côté du carré, jusquaux valeurs minimales et maximales, avec une exception : si des valeurs sont éloignées du carré de plus de 1,5 fois lécart interquartile (la hauteur du carré), alors on les représente sous forme de points (symbolisant des valeurs considérées comme extrêmes). Nous discuterons plus en détail des toutes ces mesures au chapitre 16. Voici le graphique boîte à moustaches représentant les variables marital et age. ggplot(data = gss_cat, aes(x = marital, y = age))+ geom_boxplot() #&gt; Warning: Removed 76 rows containing non-finite values (stat_boxplot). Pour mieux visualiser vos boîtes à moustache, vous pouvez les colorier. Si nous voulons colorier les boîtes en fonction de la variable marital, nous ajoutons loption fill = marital.. ggplot(data = gss_cat, aes(x = marital, y = age, fill = marital))+ geom_boxplot() #&gt; Warning: Removed 76 rows containing non-finite values (stat_boxplot). 12.3.2 Représentation graphique - diagramme en violon Nous pouvons également visualiser le lien entre une variable qualitative et une variable quantitative à laide dun diagramme en violon. Linterprétation du diagramme en violon est la suivante: La largeur du diagramme nous renseigne sur la fréquence dapparition de la variable. Plus ils sont larges, plus la valeur de la variable est fréquente et inversement. Nous pouvons représenter les diagrammes en violon de la variable marital et de la variable age. ggplot(data = gss_cat, aes(x = marital, y = age))+ geom_violin() #&gt; Warning: Removed 76 rows containing non-finite values (stat_ydensity). Nous pouvons ajouter de la couleur avec loption fill. ggplot(data = gss_cat, aes(x = marital, y = age, fill = marital))+ geom_violin() #&gt; Warning: Removed 76 rows containing non-finite values (stat_ydensity). Nous pouvons bien sûr superposer des boîtes à moustaches et des diagrammes en violon. ggplot(data = gss_cat, aes(x = marital, y = age, fill = marital))+ geom_violin()+ geom_boxplot(width = 0.1) #&gt; Warning: Removed 76 rows containing non-finite values (stat_ydensity). #&gt; Warning: Removed 76 rows containing non-finite values (stat_boxplot). 12.4 Croisement de deux variables quantitatives #ggplot(data = flights, aes(x = dep_delay, y = arr_delay))+ # geom_point(alpha = 0.25) "],["proportions.html", "Chapitre 13 Les proportions 13.1 Mise en place", " Chapitre 13 Les proportions Les proportions, exprimées en pourcentage (%), permettent de comparer la taille de deux ensembles. Le symbole utilisé pour représenter une proportion dépend doù proviennent les données. Si les données proviennent dune population, la proportion sera notée \\(\\pi\\). Si elles proviennent dun échantillon, la proportion sera notée \\(\\hat{p}\\). Attention: \\(\\pi\\) indique une proportion et ne représente donc pas 3,1415 13.1 Mise en place library(tidyverse) library(questionr) library(knitr) "],["tendancecentrale.html", "Chapitre 14 Les mesures de tendance centrale 14.1 Mise en place 14.2 Le mode 14.3 La médiane 14.4 La moyenne", " Chapitre 14 Les mesures de tendance centrale Dans ce chapitre, nous verrons comment utiliser R pour calculer les mesures importantes permettant de résumer des données. Nous allons charger les librairies que nous allons utiliser: 14.1 Mise en place library(questionr) library(ggplot2) library(nycflights13) Les mesures de tendance centrale permettent de déterminer où se situe le centre\" des données. Les trois mesures de tendance centrale sont le mode, la moyenne et la médiane. 14.2 Le mode Le mode est la modalité, valeur ou classe possédant la plus grande fréquence. En dautres mots, cest la donnée la plus fréquente. Puisque le mode se préoccupe seulement de la donnée la plus fréquente, il nest pas influencé par les valeurs extrêmes. Lorsque le mode est une classe, il est appelé classe modale. Le mode est noté Mo. Le langage R ne possède pas de fonction permettant de calculer le mode. La façon la plus simple de le calculer est dutiliser la fonction table de R. Par exemple, si nous voulons connaître le mode de la variable marital de la base de données gss_cat: table(gss_cat$marital) #&gt; #&gt; No answer Never married Separated Divorced Widowed #&gt; 17 5416 743 3383 1807 #&gt; Married #&gt; 10117 Nous remarquons que le maximum est à la modalité Married avec une fréquence de 10117. Si nous nous intéressons au mode dune variable quantitative discrète comme age de la base de données gss_cat nous obtenons: table(gss_cat$age) #&gt; #&gt; 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #&gt; 91 249 251 278 298 361 344 396 400 385 387 376 433 407 445 425 425 417 428 438 #&gt; 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #&gt; 426 415 452 434 405 448 432 404 422 435 424 417 430 390 400 396 387 365 384 321 #&gt; 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #&gt; 326 323 338 307 310 292 253 259 231 271 205 201 213 206 189 152 180 179 171 137 #&gt; 78 79 80 81 82 83 84 85 86 87 88 89 #&gt; 150 135 127 119 105 99 100 75 74 54 57 148 Nous remarquons que le maximum est à la valeur 40 avec une fréquence de 452. Dans le cas dune variable quantitative continue, pour calculer le mode, il faut commencer par séparer les données en classes. Nous utiliserons les mêmes classes utilisées à la section: carat_class = cut(diamonds$carat, breaks = seq(from = 0, to = 6, by = 1), right = FALSE) table(carat_class) #&gt; carat_class #&gt; [0,1) [1,2) [2,3) [3,4) [4,5) [5,6) #&gt; 34880 16906 2114 34 5 1 La classe modale est donc la classe [0,1) avec une fréquence de 34880. 14.3 La médiane La médiane, notée Md, est la valeur qui sépare une série de données classée en ordre croissant en deux parties égales. La médiane étant la valeur du milieu, elle est la valeur où le pourcentage cumulé atteint 50%. Puisque la médiane se préoccupe seulement de déterminer où se situe le centre des données, elle nest pas influencée par les valeurs extrêmes. Elle est donc une mesure de tendance centrale plus fiable que la moyenne. Important : La médiane nest définie que pour les variables quantitatives. En effet, si vous tentez dutiliser la médiane pour des données autres que numériques, R vous donnera un message derreur. La fonction median permet de calculer la médiane en langage R. Par exemple, pour calculer la médiane de la variable carat de la base de données diamonds, nous avons: median(diamonds$carat) #&gt; [1] 0.7 Ceci signifie que 50% des diamants ont une valeur en carat inférieure ou égale à 0.7 et que 50% des diamants ont une valeur en carat supérieure ou égale à 0.7. Nous pouvons aussi obtenir que la médiane de la variable price de la base de données diamonds est donnée par: median(diamonds$price) #&gt; [1] 2401 14.4 La moyenne La moyenne est la valeur qui pourrait remplacer chacune des données dune série pour que leur somme demeure identique. Intuitivement, elle représente le centre déquilibre dune série de données. La somme des distances qui sépare les données plus petites que la moyenne devrait être la même que la somme des distances qui sépare les données plus grandes. Important : La moyenne nest définie que pour les variables quantitatives. En effet, si vous tentez dutiliser la moyenne pour des données autres que numériques, R vous donnera un message derreur. La fonction mean permet de calculer la moyenne en langage R. Par exemple, pour calculer la moyenne de la variable carat de la base de données diamonds, nous avons: mean(diamonds$carat) #&gt; [1] 0.798 Nous pouvons aussi obtenir que la moyenne de la variable price de la base de données diamonds est donnée par: mean(diamonds$price) #&gt; [1] 3933 "],["mesuresdispersion.html", "Chapitre 15 Les mesures de dispersion 15.1 Létendue 15.2 La variance 15.3 Lécart-type 15.4 Le coefficient de variation", " Chapitre 15 Les mesures de dispersion Les mesures de tendance centrale (mode, moyenne et médiane) ne permettent pas de déterminer si une série de données est principalement située autour de son centre, ou si au contraire elle est très dispersée. Les mesures de dispersion, elles, permettent de déterminer si une série de données est centralisée autour de sa moyenne, ou si elle est au contraire très dispersée. Les mesures de dispersion sont létendue, la variance, lécart-type et le coefficient de variation. 15.1 Létendue La première mesure de dispersion, létendue, est la différence entre la valeur maximale et la valeur minimale. Létendue ne tenant compte que du maximum et du minimum, elle est grandement influencée par les valeurs extrêmes. Elle est donc une mesure de dispersion peu fiable. La fonction range permet de calculer létendue dune variable en langage R. Par exemple, pour calculer létendue de la variable carat de la base de données diamonds, nous avons: range(diamonds$carat) #&gt; [1] 0.20 5.01 Nous pouvons donc calculer létendue de la variable carat en soustrayant les deux valeurs obtenues par la fonction range, cest-à-dire que létendue est 5.01-0.2 = 4.81. 15.2 La variance La variance sert principalement à calculer lécart-type, la mesure de dispersion la plus connue. Attention : Les unités de la variance sont des unités2. La fonction var permet de calculer la variance dune variable en langage R. Par exemple, pour calculer la variance de la variable carat de la base de données diamonds, nous avons: var(diamonds$carat) #&gt; [1] 0.225 Ceci signifie que la variance de la variable carat est 0.225 carat2. 15.3 Lécart-type Lécart-type est la mesure de dispersion la plus couramment utilisée. Il peut être vu comme la « moyenne » des écarts entre les données et la moyenne. Puisque lécart-type tient compte de chacune des données, il est une mesure de dispersion beaucoup plus fiable que létendue. Il est défini comme la racine carrée de la variance. La fonction sd permet de calculer lécart-type dune variable en langage R. Par exemple, pour calculer lécart-type de la variable carat de la base de données diamonds, nous avons: sd(diamonds$carat) #&gt; [1] 0.474 Ceci signifie que lécart-type de la variable carat est 0.474 carat. 15.4 Le coefficient de variation Le coefficient de variation, noté C. V., est calculé comme suit : \\[\\begin{equation} C.V. = \\dfrac{\\text{ecart-type}}{\\text{moyenne}}\\times 100\\% \\end{equation}\\] Si le coefficient est inférieur à 15%, les données sont dites homogènes. Cela veut dire que les données sont situées près les unes des autres. Dans le cas contraire, les données sont dites hétérogènes. Cela veut dire que les données sont très dispersées. Important : Le coefficient de variation ne possède pas dunité, outre le symbole de pourcentage. Il nexiste pas de fonctions en R permettant de calculer directement le coefficient de variation. Par contre, nous pouvons utiliser en conjonction les fonctions sd et mean pour le calculer. Par exemple, pour calculer le coefficient de variation de la variable carat de la base de données diamonds, nous avons: sd(diamonds$carat)/mean(diamonds$carat)*100 #&gt; [1] 59.4 Le C.V. de la variable carat est donc 59.404 %, ce qui signifie que les données sont hétérogènes, car le coefficient de variation est plus grand que 15%. "],["mesuresposition.html", "Chapitre 16 Les mesures de position 16.1 La cote z 16.2 Les quantiles 16.3 La commande summary 16.4 Le rang centile", " Chapitre 16 Les mesures de position Les mesures de position permettent de situer une donnée par rapport aux autres. Les différentes mesures de position sont la cote Z, les quantiles et les rangs. Tout comme les mesures de dispersion, celles-ci ne sont définies que pour une variable quantitative. 16.1 La cote z Cette mesure de position se base sur la moyenne et lécart-type. La cote Z dune donnée x est calculée comme suit : \\[\\begin{equation} Z = \\dfrac{x-\\text{moyenne}}{\\text{ecart-type}} \\end{equation}\\] Important : La cote z ne possède pas dunités. Une cote Z peut être positive, négative ou nulle. Cote Z Interprétation Z&gt;0 donnée supérieure à la moyenne Z&lt;0 donnée inférieure à la moyenne Z=0 donnée égale à la moyenne Il nexiste pas de fonctions en R permettant de calculer directement la cote Z. Par contre, nous pouvons utiliser en conjonction les fonctions sd et mean pour la calculer. Par exemple, si nous voulons calculer la cote Z dun diamant de 3 carats, nous avons: (3-mean(diamonds$carat))/sd(diamonds$carat) #&gt; [1] 4.65 16.2 Les quantiles Un quantile est une donnée qui correspond à un certain pourcentage cumulé. Parmi les quantiles, on distingue les quartiles, les quintiles, les déciles et les centiles. Les quartiles Q1, Q2 et Q3, séparent les données en quatre parties égales. Environ 25% des données sont inférieures ou égales à Q1. Environ 50% des données sont inférieures ou égales à Q2. Environ 75% des données sont inférieures ou égales à Q3. Les quintiles V1, V2, V3 et V4, séparent les données en cinq parties égales. Environ 20% des données sont inférieures ou égales à V1. Environ 40% des données sont inférieures ou égales à V2. Etc. Les déciles D1, D2, , D8 et D9, séparent les données en dix parties égales. Environ 10% des données sont inférieures ou égales à D1. Environ 20% des données sont inférieures ou égales à D2. Etc. Les centiles C1, C2, , C98 et C99, séparent les données en cent parties égales. Environ 1% des données sont inférieures ou égales à C1. Environ 2% des données sont inférieures ou égales à C2. Etc. Il est utile de noter que certains quantiles se recoupent. La fonction quantile permet de calculer nimporte quel quantile dune variable en langage R. Il suffit dindiquer la variable étudiée ainsi que le pourcentage du quantile voulu. Par exemple, si nous voulons calculer D1 pour la variable carat, nous allons utiliser la fonction quantile avec une probabilité de 0,1. quantile(diamonds$carat, 0.1) #&gt; 10% #&gt; 0.31 Ceci implique que 10% des diamants ont une valeur en carat inférieure ou égale à 0.31 carat. Nous pouvons calculer le troisième quartile Q3 de la variable price en utilisant la fonction quantile avec une probabilité de 0,75. quantile(diamonds$price, 0.75) #&gt; 75% #&gt; 5324 Ceci implique que 75% des diamants ont un prix en dollars inférieur ou égal à 5324.25 $. 16.3 La commande summary La commande summary produit un sommaire contenant six mesures importantes: Min : le minimum de la variable 1st Qu.: Le premier quartile, Q1, de la variable Median : La médiane de la variable Mean : La moyenne de la variable 3rd Qu. : Le troisième quartile, Q3, de la variable Max : Le maximum de la variable Nous pouvons donc produire le sommaire de la variable price de la base de données diamonds de la façon suivante: summary(diamonds$price) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 326 950 2401 3933 5324 18823 16.4 Le rang centile Un rang centile représente le pourcentage cumulé, exprimé en nombre entier, qui correspond à une certaine donnée. Nous déterminerons les rangs centiles pour les variables continues seulement. Les rangs centiles sont donc exactement linverse des centiles. Il nexiste pas de fonctions dans R permettant de trouver directement le rang centile, mais il est facile dutiliser la fonction mean pour le trouver. Par exemple, si nous voulons trouver le rang centile dun diamant qui coûte 500$, il suffit dutiliser la commande suivante. La commande calcule la moyenne de toutes les valeurs en dollars des diamants coûtant 500$ ou moins. mean(diamonds$price&lt;=500) #&gt; [1] 0.0324 Ceci signifie que pour un diamant de 500$, il y a 3.242 % des diamants qui ont une valeur égale ou inférieure. "],["serieschronologiques.html", "Chapitre 17 Les séries chronologiques 17.1 Mise en place 17.2 Criminalité à Montréal 17.3 Airbnb 17.4 DSLABS 17.5 FIVETHIRTYEIGHT", " Chapitre 17 Les séries chronologiques Une série chronologique est un ensemble de valeurs observées dune variable quantitative. Elle permet danalyser lévolution de cette variable dans le temps dans le but éventuel de faire des prévisions. Le tableau utilisé pour représenter les données dune série chronologique comporte une colonne pour la période ainsi quune colonne pour la valeur observée. Pour ce chapitre, nous utiliserons la librairie gapminder. 17.1 Mise en place library(tidyverse) library(questionr) library(gapminder) library(knitr) canada &lt;- gapminder %&gt;% filter(country %in% c(&quot;Canada&quot;)) %&gt;% select(year,lifeExp) canada #&gt; # A tibble: 12 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 68.8 #&gt; 2 1957 70.0 #&gt; 3 1962 71.3 #&gt; 4 1967 72.1 #&gt; 5 1972 72.9 #&gt; 6 1977 74.2 #&gt; # ... with 6 more rows ggplot(data = canada, aes(x = year, y = lifeExp))+ geom_line()+ geom_point() Le génocide Rwandais gapminder %&gt;% filter(country %in% c(&quot;Rwanda&quot;)) %&gt;% select(year,lifeExp) %&gt;% ggplot(aes(x = year, y = lifeExp))+ geom_line()+ geom_point() 17.2 Criminalité à Montréal # On lit les données disponibles sur le web. criminalite &lt;- read_csv(&quot;https://data.montreal.ca/dataset/5829b5b0-ea6f-476f-be94-bc2b8797769a/resource/c6f482bf-bf0f-4960-8b2f-9982c211addd/download/interventionscitoyendo.csv&quot;, locale = locale(encoding = &#39;ISO-8859-1&#39;)) #criminalite &lt;- read_csv(here::here(&quot;data&quot;,&quot;criminalite-2015-2018.csv&quot;), locale = locale(encoding = &#39;ISO-8859-1&#39;)) criminalite %&gt;% group_by(CATEGORIE, DATE, QUART) %&gt;% summarise(Nombre = n()) %&gt;% ggplot(aes(x = DATE, y = Nombre, color = QUART))+ geom_line()+ facet_wrap(~ CATEGORIE) #&gt; `summarise()` has grouped output by &#39;CATEGORIE&#39;, &#39;DATE&#39;. You can override using the `.groups` argument. criminalite %&gt;% filter(DATE &gt; &quot;2016-06-30&quot; &amp; DATE &lt; &quot;2016-08-01&quot;) %&gt;% group_by(CATEGORIE, DATE, QUART) %&gt;% summarise(Nombre = n()) %&gt;% ggplot(aes(x = DATE, y = Nombre, color = QUART))+ geom_path()+ facet_wrap(~CATEGORIE) #&gt; `summarise()` has grouped output by &#39;CATEGORIE&#39;, &#39;DATE&#39;. You can override using the `.groups` argument. #&gt; geom_path: Each group consists of only one observation. Do you need to adjust #&gt; the group aesthetic? 17.3 Airbnb Sur le site où les données ont été prises, nous pour vons utiliser une autre base de données calendar. Par contre, le fichier fait 100 Mo et prend plusieurs minutes à être lu par read_csv. On pourrait unir les deux bases de données pour connaître le nombre moyen de jours doccupations, etc On veut retrouver les statistiques calculées ici airbnb montreal. airbnb &lt;- read_csv(&quot;http://data.insideairbnb.com/canada/qc/montreal/2016-05-04/visualisations/listings.csv&quot;) #airbnb &lt;- read_csv(here::here(&quot;data&quot;, &quot;airbnb-listings-mtl.csv&quot;)) #calendar &lt;- read_csv(here::here(&quot;data&quot;, &quot;airbnb-calendar-mtl.csv&quot;), n_max = 526400) 17.3.1 Catégorie de logement kable(freq(airbnb$room_type, total = TRUE, valid = FALSE)) n % Entire home/apt 6377 60.1 Private room 4092 38.5 Shared room 150 1.4 Total 10619 100.0 ggplot(data = airbnb, mapping = aes(x = room_type, fill = room_type))+ geom_bar()+ labs( x = &quot;Type de logement&quot;, y = &quot;Fréquence&quot; ) La moyenne du prix par nuit. mean(airbnb$price) #&gt; [1] 90.6 17.3.2 Availability Création dune nouvelle colonne pour avoir haute (plus de 90 jours par année) et basse (90 jours ou moins par année) disponibilité. airbnb_av &lt;- airbnb %&gt;% mutate(disponibilite = if_else(availability_365 &gt; 90, &quot;haute&quot;, &quot;basse&quot;)) kable(freq(airbnb_av$disponibilite, total = TRUE, valid = FALSE)) n % basse 3774 35.5 haute 6845 64.5 Total 10619 100.0 Les logements sont disponibles en moyenne combien de jours par année? mean(airbnb$availability_365) #&gt; [1] 197 ggplot(data = airbnb, mapping = aes(x = availability_365))+ geom_bar()+ labs( x = &quot;Nombre de jours disponibles par année&quot;, y = &quot;Fréquence&quot; ) 17.3.3 Nombre de logements par hôtes Création dune nouvelle colonne pour savoir si lhôte possède un seul logement ou plusieurs. airbnb_mult &lt;- airbnb %&gt;% mutate(multi = if_else(calculated_host_listings_count &gt; 1, &quot;Multi&quot;, &quot;Unique&quot;)) kable(freq(airbnb_mult$multi, total = TRUE, valid = FALSE)) n % Multi 3336 31.4 Unique 7283 68.6 Total 10619 100.0 ggplot(data = airbnb, mapping = aes(x = calculated_host_listings_count))+ geom_bar()+ labs( x = &quot;Nombre de logements au nom de l&#39;hôte&quot;, y = &quot;Fréquence&quot; ) 17.4 DSLABS La librairie 17.5 FIVETHIRTYEIGHT library(fivethirtyeight) #&gt; Warning: le package &#39;fivethirtyeight&#39; a été compilé avec la version R 4.0.5 #&gt; Some larger datasets need to be installed separately, like senators and #&gt; house_district_forecast. To install these, we recommend you install the #&gt; fivethirtyeightdata package by running: #&gt; install.packages(&#39;fivethirtyeightdata&#39;, repos = #&gt; &#39;https://fivethirtyeightdata.github.io/drat/&#39;, type = &#39;source&#39;) polls &lt;- as.tibble(generic_polllist) polls %&gt;% select(enddate, pollster, adjusted_dem, adjusted_rep) %&gt;% rename(Democrates = adjusted_dem, Republicains = adjusted_rep) %&gt;% gather(parti, percentage, -enddate, -pollster) %&gt;% mutate(parti = factor(parti, levels = c(&quot;Democrates&quot;,&quot;Republicains&quot;))) %&gt;% ggplot(aes(enddate, percentage, color = parti)) + geom_point(show.legend = FALSE, alpha=0.4) + geom_smooth(method = &quot;loess&quot;, span = 0.15) + scale_y_continuous(limits = c(30,50)) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; #&gt; Warning: Removed 78 rows containing non-finite values (stat_smooth). #&gt; Warning: Removed 78 rows containing missing values (geom_point). "],["donneesconstruites.html", "Chapitre 18 Les données construites 18.1 Mise en place", " Chapitre 18 Les données construites 18.1 Mise en place library(tidyverse) library(questionr) library(knitr) "],["correlationlineaire.html", "Chapitre 19 La corrélation linéaire 19.1 Mise en place 19.2 Le nuage de points 19.3 Fake data 19.4 Le quartet dAnscombe 19.5 DatasauRus 19.6 Challenger", " Chapitre 19 La corrélation linéaire La corrélation est létude de lintensité du lien entre deux variables. Elle permet de quantifier la relation entre deux variables quantitatives. Bien quà priori le lien de dépendance ne soit pas toujours évident entre ces deux variables, il est pratique, à des fins danalyse, de définir la variable indépendante \\(X\\) et la variable dépendante \\(Y\\). 19.1 Mise en place Nous utiliserons les librairies suivantes pour ce chapitre. library(tidyverse) library(datasauRus) library(knitr) Dans ce chapitre, nous utiliserons la base de données starwars qui est chargée par lextension dplyr du tidyverse. Les informations présentes dans cette base de données sont: variable description name Name of the character height Height (cm) mass Weight (kg) hair_color,skin_color,eye_color Hair, skin, and eye colors birth_year Year born (BBY = Before Battle of Yavin) gender male, female, hermaphrodite, or none. homeworld Name of homeworld species Name of species films List of films the character appeared in vehicles List of vehicles the character has piloted starships List of starships the character has piloted Nous pouvons avoir un meilleur apercu des différentes variables de la base de données en utilisant la commande glimpse. glimpse(starwars) #&gt; Rows: 87 #&gt; Columns: 14 #&gt; $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, &quot;Leia Or~ #&gt; $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, 180, 2~ #&gt; $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 84.0, 77.~ #&gt; $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;brown&quot;, N~ #&gt; $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;light&quot;, &quot;~ #&gt; $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;, &quot;blue&quot;,~ #&gt; $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0, 57.0, ~ #&gt; $ sex &lt;chr&gt; &quot;male&quot;, &quot;none&quot;, &quot;none&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,~ #&gt; $ gender &lt;chr&gt; &quot;masculine&quot;, &quot;masculine&quot;, &quot;masculine&quot;, &quot;masculine&quot;, &quot;femini~ #&gt; $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alderaan&quot;, &quot;T~ #&gt; $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Huma~ #&gt; $ films &lt;list&gt; &lt;&quot;The Empire Strikes Back&quot;, &quot;Revenge of the Sith&quot;, &quot;Return~ #&gt; $ vehicles &lt;list&gt; &lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &quot;Imp~ #&gt; $ starships &lt;list&gt; &lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Advanced x1&quot;,~ 19.2 Le nuage de points Dans le cours de méthodes quantitatives, nous nous intéressons à la corrélation linéaire. Un nuage de points permet de visualiser les données. Pour construire ce graphique: Le titre doit être indiqué : Lien entre variable 1 et variable 2. La variable indépendante est placée sur laxe des \\(x\\) et la variable dépendante est placée sur laxe des \\(y\\). Les titres des axes doivent être présents. Un point doit être placé à la coordonnée \\((x_i,y_i)\\) pour chacun des couples de données. Les axes \\(x\\) et \\(y\\) peuvent être coupés pour améliorer la présentation. Nous allons débuter par représenter les deux variables étudiées:. Puisque la base de données contient 87, nous nafficherons que les premières données. height mass 172 77 167 75 96 32 202 136 150 49 178 120   Nous allons nous intéresser aux variables height et mass de la base de données starwars. Puisque la masse (mass) dépend de la taille (height), la variable mass est la variable dépendante et la variable height est la variable indépendante. Nous affichons ces données dans un plan cartésien et chaque ligne du tableau précédent correspond aux coordonnées cartésiennes de nos points. Par exemple, puisque le premier personnage à une taille de 172 et un poids de 77, nous allons afficher le point (172,77). Si nous le faisons pour toutes les données, nous obtenons un nuage de points. Nous avons donc: ggplot(data = starwars, aes(x = height, y = mass))+ geom_point()+ labs( x = &quot;Taille (cm)&quot;, y = &quot;Masse (kg)&quot;, title = &quot;Lien entre la taille et la masse&quot; ) #&gt; Warning: Removed 28 rows containing missing values (geom_point). Nous remarquons une donnée qui semble aberrante dans le graphique précédent. Le personnage de Star Wars semble avoir une masse très importante par rapport à sa taille. Puisque sa masse dépasse 1000kg, nous allons filtrer les données pour trouver le nom du personnage en question. starwars %&gt;% filter(mass &gt; 1000) #&gt; # A tibble: 1 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Jabba ~ 175 1358 &lt;NA&gt; green-tan,~ orange 600 herma~ mascu~ #&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; Le personnage est bien sûr Jabba Desilijic Tiure. Jabba Il est possible de quantifier la force de la corrélation linéaire entre deux variables à laide dune mesure. Cette mesure est appelée le coefficient de corrélation et est noté \\(r\\). La formule pour calculer \\(r\\) est la suivante: \\[ r = \\dfrac{\\sum xy - n\\bar x \\bar y}{(n-1)s_x s_y} \\] Nous pouvons utiliser la commande cor dans R pour trouver le coefficient de corrélation. Par exemple, si nous voulons trouver le coefficient de corrélation entre les variables height et mass: cor(starwars$height,starwars$mass) #&gt; [1] NA Nous obtenons comme réponse NA. Ceci signifie que des données sont manquantes dans nos observations. Pour calculer un coefficient de corrélation en omettant les données manquantes, nous pouvons utiliser loption use = \"complete.obs\". Nous obtenons donc: cor(starwars$height, starwars$mass, use = &quot;complete.obs&quot;) #&gt; [1] 0.134 Le coefficient de corrélation est donc de 0.134. Nous pouvons calculer le coefficient de corrélation lorsque nous enlevons lobservation de Jabba Desilijic Tiure. Nous obtenons: no_jabba &lt;- starwars %&gt;% filter(mass &lt; 1000) cor(no_jabba$height, no_jabba$mass) #&gt; [1] 0.761 Le coefficient de corrélation est maintenant de 0.761. La valeur de \\(r\\) permet de quantifier la force de la corrélation entre \\(X\\) et \\(Y\\) et permet aussi de déterminer si cette corrélation est positive ou négative. 19.3 Fake data 19.3.1 Corrélation positive 19.3.2 Corrélation négative 19.3.3 Aucune corrélation 19.3.4 Une autre façon de simuler N &lt;- 50 # Nombre de points x0 &lt;- 0 xf &lt;- 1 delta &lt;- (xf-x0)/N x &lt;- seq(x0, xf, delta) y_pos_high &lt;- x+b+rnorm(N+1, 0, (0.25)^2) y_pos_low &lt;- x+b+rnorm(N+1, 0, (0.5)^2) y_neg_high &lt;- -x+1+rnorm(N+1, 0, (0.25)^2) y_neg_low &lt;- -x+1+rnorm(N+1, 0, (0.5)^2) cor_lin &lt;- rbind( tibble( type = &quot;Corrélation positive forte&quot;, x, y = y_pos_high), tibble( type = &quot;Corrélation positive faible&quot;, x, y = y_pos_low), tibble( type = &quot;Corrélation négative forte&quot;, x, y = y_neg_high), tibble( type = &quot;Corrélation négative faible&quot;, x, y = y_neg_low) ) ggplot(cor_lin, aes(x, y))+ geom_point()+ facet_wrap(~type)+ theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank())+ xlim(-0,1)+ ylim(-0.5,1.5) 19.3.5 Autre essai moderndive #&gt; Warning: `as_data_frame()` was deprecated in tibble 2.0.0. #&gt; Please use `as_tibble()` instead. #&gt; The signature and semantics have changed, see `?as_tibble`. #&gt; Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. #&gt; Using compatibility `.name_repair`. Figure 19.1: Different correlation coefficients 19.4 Le quartet dAnscombe Le quartet dAnscombe est constitué de quatre ensembles de données qui ont les mêmes propriétés statistiques simples mais qui sont en réalité très différents, ce qui se voit facilement lorsquon les représente sous forme de graphiques. Ils ont été construits en 1973 par le statisticien Francis Anscombe dans le but de démontrer limportance de tracer des graphiques avant danalyser des données, car cela permet notamment destimer lincidence des données aberrantes sur les différentes indices statistiques que lon pourrait calculer. Le quartet dAnscombe est disponible dans R sous le nom anscombe. kable(anscombe) x1 x2 x3 x4 y1 y2 y3 y4 10 10 10 8 8.04 9.14 7.46 6.58 8 8 8 8 6.95 8.14 6.77 5.76 13 13 13 8 7.58 8.74 12.74 7.71 9 9 9 8 8.81 8.77 7.11 8.84 11 11 11 8 8.33 9.26 7.81 8.47 14 14 14 8 9.96 8.10 8.84 7.04 6 6 6 8 7.24 6.13 6.08 5.25 4 4 4 19 4.26 3.10 5.39 12.50 12 12 12 8 10.84 9.13 8.15 5.56 7 7 7 8 4.82 7.26 6.42 7.91 5 5 5 8 5.68 4.74 5.73 6.89 Les observations \\(x_i\\) sont reliées aux observations \\(y_i\\). Pour visualiser ces quatre ensembles de données, nous avons produit une nouvelle base de données anscombe_tidy sous la forme de tidy data. Avant dafficher les ensembles de données, nous allons calculer quelques mesures sur chacun de ces ensembles, à savoir, la moyenne des \\(x\\), la moyenne des \\(y\\), la variance des \\(x\\), la variance des \\(y\\) et le coefficient de corrélation. anscombe_tidy %&gt;% group_by(ensemble) %&gt;% summarise(&quot;moyenne des $x$&quot;=mean(x), &quot;variance des $x$&quot;=var(x), &quot;moyenne des $y$&quot;=mean(y), &quot;variance des $y$&quot;=var(y), &quot;coeff. de corrélation&quot;=cor(x,y)) %&gt;% kable ensemble moyenne des \\(x\\) variance des \\(x\\) moyenne des \\(y\\) variance des \\(y\\) coeff. de corrélation I 9 11 7.5 4.13 0.816 II 9 11 7.5 4.13 0.816 III 9 11 7.5 4.12 0.816 IV 9 11 7.5 4.12 0.817 Comme nous pouvons le remarquer, les quatre ensembles de données possèdent les mêmes mesures. Par contre, lorsque nous affichons ensuite les quatre ensembles de données, nous remarquons que ces ensembles sont très différents. ggplot(anscombe_tidy, aes(x, y)) + geom_point() + facet_wrap(~ ensemble) + geom_smooth(method = &quot;lm&quot;, se = FALSE) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; 19.5 DatasauRus datasaurus_dozen %&gt;% group_by(dataset) %&gt;% summarise(&quot;moyenne des $x$&quot;=mean(x), &quot;variance des $x$&quot;=var(x), &quot;moyenne des $y$&quot;=mean(y), &quot;variance des $y$&quot;=var(y), &quot;coeff. de corrélation&quot;=cor(x,y)) %&gt;% kable dataset moyenne des \\(x\\) variance des \\(x\\) moyenne des \\(y\\) variance des \\(y\\) coeff. de corrélation away 54.3 281 47.8 726 -0.064 bullseye 54.3 281 47.8 726 -0.069 circle 54.3 281 47.8 725 -0.068 dino 54.3 281 47.8 726 -0.064 dots 54.3 281 47.8 725 -0.060 h_lines 54.3 281 47.8 726 -0.062 high_lines 54.3 281 47.8 726 -0.069 slant_down 54.3 281 47.8 726 -0.069 slant_up 54.3 281 47.8 726 -0.069 star 54.3 281 47.8 725 -0.063 v_lines 54.3 281 47.8 726 -0.069 wide_lines 54.3 281 47.8 726 -0.067 x_shape 54.3 281 47.8 725 -0.066 ggplot(datasaurus_dozen, aes(x=x, y=y, colour=dataset))+ geom_point()+ theme_void()+ theme(legend.position = &quot;none&quot;)+ facet_wrap(~dataset, ncol=3) 19.6 Challenger kable(orings) fligth temperature damaged 1 53 2 2 57 1 3 58 1 4 63 1 5 66 0 6 67 0 7 67 0 8 67 0 9 68 0 10 69 0 11 70 1 12 70 1 13 70 0 14 70 0 15 72 0 16 73 0 17 75 2 18 75 0 19 76 0 20 76 0 21 78 0 22 79 0 23 81 0 19.6.1 Toutes les données ggplot(data = orings, aes(x = temperature, y = damaged))+ geom_point() 19.6.2 Sans incident orings %&gt;% filter(damaged != 0) %&gt;% ggplot(aes(x = temperature, y = damaged))+ geom_point() 19.6.3 Probabilités en enlevant les incidents fitting &lt;- orings %&gt;% filter(damaged &gt; 0) %&gt;% mutate(proba = if_else(damaged &gt; 0, damaged/6, 0.01)) %&gt;% mutate(log = log(proba/(1-proba))) model &lt;- lm(log ~temperature, data = fitting) b &lt;- model$coefficients[[1]] a &lt;- model$coefficients[[2]] fun &lt;- function(x){6*exp(a*x+b)/(1+exp(a*x+b))} ggplot(data = fitting, aes(x = temperature, y = damaged))+ geom_point()+ stat_function(fun = fun)+ xlim(30, 90)+ ylim(0,6) 19.6.4 Probabilités en gardant les incidents fitting &lt;- orings %&gt;% mutate(proba = if_else(damaged &gt; 0, damaged/6, 0.01)) %&gt;% mutate(log = log(proba/(1-proba))) model &lt;- lm(log ~temperature, data = fitting) b &lt;- model$coefficients[[1]] a &lt;- model$coefficients[[2]] fun &lt;- function(x){6*exp(a*x+b)/(1+exp(a*x+b))} ggplot(data = orings, aes(x = temperature, y = damaged))+ geom_point()+ stat_function(fun = fun)+ xlim(30, 90)+ ylim(0,6) 19.6.5 GLM model &lt;- glm(cbind(damaged, 6-damaged)~temperature, data = orings, family = binomial) b &lt;- model$coefficients[[1]] a &lt;- model$coefficients[[2]] fun &lt;- function(x){6*exp(a*x+b)/(1+exp(a*x+b))} ggplot(data = orings, aes(x = temperature, y = damaged))+ geom_point()+ stat_function(fun = fun)+ xlim(30, 90)+ ylim(0,6) "],["bibliographie.html", "Bibliographie", " Bibliographie Barnier, Julien. 2018. Introduction à r Et Au Tidyverse. https://juba.github.io/tidyverse/. Ismay, Chester. 2018. Getting Used to r, RStudio, and r Markdown. https://ismayc.github.io/rbasics-book/. Wickham, Hadley. 2014. Tidy Data. Journal of Statistical Software, Articles 59 (10): 123. https://doi.org/10.18637/jss.v059.i10. . 2019. Tidyverse: Easily Install and Load the Tidyverse. https://CRAN.R-project.org/package=tidyverse. . 2021a. Forcats: Tools for Working with Categorical Variables (Factors). https://CRAN.R-project.org/package=forcats. . 2021b. Nycflights13: Flights That Departed NYC in 2013. https://github.com/hadley/nycflights13. Wickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. 1st ed. OReilly Media Inc. http://r4ds.had.co.nz/. "]]
